#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <sys/socket.h>
#include <signal.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <time.h>
#include <math.h>

#include <openssl/rsa.h>
#include <openssl/x509.h>
#include <openssl/sha.h>
#include <openssl/aes.h>

#include <curl/curl.h>

#define LH_DECLARE_SHORT_NAMES 1

#include "lh_debug.h"
#include "lh_buffers.h"
#include "lh_bytes.h"
#include "lh_files.h"
#include "lh_net.h"
#include "lh_event.h"
#include "lh_compress.h"
#include "lh_arr.h"

#include "ids.h"
#include "gamestate.h"
#include "mcp_game.h"

#define SERVER_ADDR "2b2t.org"

#define SERVER_PORT 25565
#define WEBSERVER_PORT 8080

#define ASYNC_THRESHOLD 500000
#define NEAR_THRESHOLD 40000

#define G_MCSERVER  1
#define G_WEBSERVER 2
#define G_PROXY     3

#define MIN(a,b) ((a<b)?(a):(b))
#define MAX(a,b) ((a>b)?(a):(b))
#define SGN(x) (((x)>=0)?1:-1)
#define SQ(x) ((x)*(x))


////////////////////////////////////////////////////////////////////////////////

int signal_caught;

void signal_handler(int signum) {
    printf("Caught signal %d, stopping main loop\n",signum);
    signal_caught = 1;
}

////////////////////////////////////////////////////////////////////////////////

lh_pollarray pa;

typedef struct {
    int x,y,z;          // block coordinates
    int v;              // type of placement, only applicable to slabs: 'u'=upper, 'd'=bottom, 'm'=default
    int id;             // block type ID
    uint8_t dir;        // 
    uint8_t cx,cy,cz;   // cursor x,y,z
} bblock;

struct {
    int state;          // handshake state

    int cs;             // connected socket to client
    int ms;             // connected socket to server

    // connections
    lh_conn * cs_conn; // to the client
    lh_conn * ms_conn; // to the server

    // decoded buffers
    lh_buf_t  cs_rx;   // client -> proxy
    lh_buf_t  cs_tx;   // proxy -> client
    lh_buf_t  ms_rx;   // server -> proxy
    lh_buf_t  ms_tx;   // proxy -> server

    // RSA structures/keys for server-side and client-side
    RSA *s_rsa; // public key only - must be freed by RSA_free
    RSA *c_rsa; // public+private key - must be freed by RSA_free

    // verification tokens
    char s_token[4]; // what we received from the server
    char c_token[4]; // generated by us, sent to client

    // AES encryption keys (128 bit)
    char s_skey[16]; // generated by us, sent to the server
    char c_skey[16]; // received from the client

    // data parsed from JSON
    char accessToken[256];
    char selectedProfile[256];
    char serverId[256];

    // server ID - we forward this to client as is, so no need
    // for client- and server side versions.
    // zero-terminated string, so no need for length value
    // Note: serverID is received as UTF-16 string, but converted to ASCII
    // for hashing. The string itself is a hexstring, but it's not converted
    // to bytes or anything
    char s_id[256];

    // DER-encoded public key from the server
    char s_pkey[1024];
    int s_pklen;

    // DER-encoded public key sent to the client
    char c_pkey[1024];
    int c_pklen;

    int encstate;
    int passfirst;

    AES_KEY c_aes;
    char c_enc_iv[16];
    char c_dec_iv[16];

    AES_KEY s_aes;
    char s_enc_iv[16];
    char s_dec_iv[16];

    int enable_encryption;

    FILE * output;
    FILE * dbg;

    // Various options
    struct {
        int autokill;

        int grinding;
        int maxlevel;

        int holeradar;

        int build;
    } opt;

    // Auto-Building
    struct {
        int active;                 // building is in progress
        uint64_t last_placement;    // timestamp when the most recent block was placed
        lh_arr_declare(bblock,all);     // all blocks to be built - init by chat command
        lh_arr_declare(bblock,inreach); // all blocks in reach - updated by player position change
        int last_x, last_y, last_z;
    } build;

    // Hole radar
    int hr_last_x;
    int hr_last_y;
    int hr_last_z;
    int hr_last_yaw;

    int64_t last[2];
} mitm;

////////////////////////////////////////////////////////////////////////////////

void write_packet(uint8_t *ptr, ssize_t len, lh_buf_t *buf) {
    uint8_t hbuf[16]; CLEAR(hbuf);
    ssize_t ll = lh_place_varint(hbuf,len) - hbuf;

    ssize_t widx = buf->C(data);
    if (mitm.dbg)
        fprintf(mitm.dbg, "%s:%d buf=%p ptr=%16p cnt=%zd adding %zd\n",
                __func__,__LINE__,buf,AR(buf->data),(len+ll));
    
    lh_arr_add(GAR4(buf->data),(len+ll));
    if (mitm.dbg)
        fprintf(mitm.dbg, "%s:%d buf=%p ptr=%16p cnt=%zd\n",
                __func__,__LINE__,buf,AR(buf->data));

    memmove(P(buf->data)+widx, hbuf, ll);
    memmove(P(buf->data)+widx+ll, ptr, len);
}

uint8_t * read_string(uint8_t *p, char *s) {
    uint32_t len = lh_read_varint(p);
    memmove(s, p, len);
    s[len] = 0;
    return p+len;
}

#define Rx(n,type,fun) type n = lh_read_ ## fun ## _be(p);

#define Rchar(n)  Rx(n,uint8_t,char)
#define Rshort(n) Rx(n,uint16_t,short)
#define Rint(n)   Rx(n,uint32_t,int)
#define Rlong(n)  Rx(n,uint64_t,long);
#define Rfloat(n) Rx(n,float,float)
#define Rdouble(n) Rx(n,double,double)
#define Rstr(n)   char n[4096]; p=read_string(p,n)
#define Rskip(n)  p+=n;
#define Rvarint(n) uint32_t n = lh_read_varint(p);

////////////////////////////////////////////////////////////////////////////////

void build_request(char **words, lh_buf_t *client) {
    char reply[32768];
    reply[0]=0;

    if (!words[1]) {
        sprintf(reply, "Usage: build <type> [ parameters ... ] or build cancel");
    }
    else if (!strcmp(words[1], "cancel")) {
        lh_arr_free(GAR(mitm.build.all));
        lh_arr_free(GAR(mitm.build.inreach));
        sprintf(reply, "Current build canceled");
        mitm.opt.build = 0;
    }
    else if (!strcmp(words[1], "floor")) {
        int xsize,zsize;
        if (!words[2] || !words[3] || 
            sscanf(words[2],"%d",&xsize)!=1 || 
            sscanf(words[3],"%d",&zsize)!=1 ) {
            sprintf(reply, "Usage: build floor <xsize> <zsize> [ypos] [u|d]");
        }
        else {
            int x = gs.own.x>>5;
            int y = (gs.own.y>>5)-1; // coords of the block just below your feet
            int z = gs.own.z>>5;

            if (words[4]) sscanf(words[4],"%d",&y);
            
            char slab = 'm';
            if (words[5]) {
                if (sscanf(words[5],"%c",&slab)!=1) {
                    sprintf(reply, "Usage: build floor <xsize> <zsize> [ypos] [u|d]");
                    chat_message(reply, client, NULL);
                    return;
                }
                if (slab != 'u' && slab != 'd') {
                    sprintf(reply, "Usage: build floor <xsize> <zsize> [ypos] [u|d]");
                    chat_message(reply, client, NULL);
                    return;
                }
            }   

            lh_arr_free(GAR(mitm.build.all)); // cancel any current build

            int i,j;
            int dx = SGN(xsize);
            int dz = SGN(zsize);
            int n=0;

            for(i=0; i<abs(xsize); i++) {
                for(j=0; j<abs(zsize); j++) {
                    bblock * bb = lh_arr_new(GAR(mitm.build.all));
                    bb->x = x+i*dx;
                    bb->y = y;
                    bb->z = z+j*dz;
                    bb->v = slab;
                    //TODO: block ID
                    //printf("Scheduled block at %d,%d,%d\n",bb->x,bb->y,bb->z);
                    n++;
                }
            }
            sprintf(reply,"Scheduled %d blocks to build",n);
            mitm.opt.build = 1;
        }        
    }

    if (reply[0])
        chat_message(reply, client, NULL);
}

#define REACH_RANGE 5

static inline int sqdist(int x, int y, int z, int x2, int y2, int z2) {
    return SQ(x-x2)+SQ(y-y2)+SQ(z-z2);
}

static inline int is_solid(int type) {
    return !(type==0 ||                  // air
             type==0x08 || type==0x09 || // water
             type==0x0a || type==0x0b || // lava
             type==0x1f ||               // tallgrass  
             type==0x06 ||               // saplings
             type==0x33                  // fire
             );
}

void build_process(lh_buf_t *client) {
    lh_arr_free(GAR(mitm.build.inreach));

    // get a cuboid in range
    int x = gs.own.x>>5;
    int y = (gs.own.y>>5)+1;
    int z = gs.own.z>>5;

    int Xl = (x>>4)-1;
    int Xh = Xl+2;
    int xoff = Xl*16;

    int Zl = (z>>4)-1;
    int Zh = Zl+2;
    int zoff = Zl*16;

    int yl = MAX(y-REACH_RANGE-1,1);
    int yh = MIN(y+REACH_RANGE+1,255);

    uint8_t *data = export_cuboid(Xl,Xh,Zl,Zh,yl,yh);
    
    // detect which blocks are OK to place in

    int i,n=0;
    for(i=0; i<C(mitm.build.all); i++) {
        bblock * bb = P(mitm.build.all)+i;

        if (bb->x == x && bb->z == z && (bb->y == y || bb->y == y-1))
            continue; // don't try to build at our own position

        if (sqdist(x,y,z,bb->x,bb->y,bb->z) > SQ(REACH_RANGE))
            continue; // this block is too far away

        int cx = bb->x-xoff;
        int cz = bb->z-zoff;

        uint8_t *ydata = data+48*48*(bb->y-yl);
        uint8_t *b = ydata+cx+cz*48;

        // is the block type suitable to build in ?
        if (!is_solid(*b)) {
            bb->dir = 255;

            // find direction from which the block can be built
            if (is_solid(b[48*48]) && bb->v!='d')         {  // U
                bb->dir = 0; bb->cx=8;  bb->cy=0;  bb->cz=8;
            }
            else if (is_solid(b[-(48*48)]) && bb->v!='u') {  // D
                bb->dir = 1; bb->cx=8;  bb->cy=16; bb->cz=8;
            }
            else if (is_solid(b[48]))       { bb->dir = 2; bb->cx=8;  bb->cy=8;  bb->cz=0;  } // S
            else if (is_solid(b[-48]))      { bb->dir = 3; bb->cx=8;  bb->cy=8;  bb->cz=16; } // N
            else if (is_solid(b[1]))        { bb->dir = 4; bb->cx=0;  bb->cy=8;  bb->cz=8;  } // E
            else if (is_solid(b[-1]))       { bb->dir = 5; bb->cx=16; bb->cy=8;  bb->cz=8;  } // W
            else { continue; }
            
            // adjust the block placement for the slabs
            if ( bb->cy == 8) {
                if (bb->v == 'u') bb->cy = 12;
                if (bb->v == 'd') bb->cy = 4;
            }


            // schedule it for handle_async
            bblock * ir = lh_arr_new(GAR(mitm.build.inreach));
            *ir = *bb;
            n++;
        }
    }

#if 0
    char reply[32768];
    sprintf(reply,"Scheduled %d blocks for handle_async",n);
    chat_message(reply,client,NULL);
#endif

    mitm.build.active = (n>0);

    free(data);



    // update mitm.build.inreach array
    // schedule blocks for handle_async
}

void salt_request(int x, int y, int z) {
    uint8_t pkt[4096], *p;

    // place block
    p = pkt;
    write_varint(p,0x08); // PlayerBlockPlacement
    write_int(p,x);
    write_char(p,y);
    write_int(p,z);
    write_char(p,4);
    write_short(p,0xffff); //TODO: proper slot data
    write_char(p,1);       
    write_char(p,7);       
    write_char(p,4);        
    write_packet(pkt, p-pkt, &mitm.cs_tx);

    // wave arm
    p = pkt;
    write_varint(p,0x0a); // Animation
    write_int(p,gs.own.id);
    write_char(p,0x01);
    write_packet(pkt, p-pkt, &mitm.cs_tx);
}


#include "blocks_ansi.h"

int process_message(const char *msg, lh_buf_t *forw, lh_buf_t *retour) {
    if (msg[0] != '#') return 0;

    // tokenize
    char *words[256];
    CLEAR(words);
    int w=0;

    char wbuf[4096];
    strncpy(wbuf, msg+1, sizeof(wbuf));
    char *wsave;

    char *wstr = wbuf;
    do {
        words[w++] = strtok_r(wstr, " ", &wsave);
        wstr = NULL;
    } while(words[w-1]);
    w--;

    if (w==0) return 0;


    uint8_t reply[32768];
    reply[0] = 0;

    if (!strcmp(words[0],"test")) {
        sprintf(reply,"Chat test response");
    }
    else if (!strcmp(words[0],"entities")) {
        sprintf(reply,"Tracking %zd entities",gs.C(entity));
    }
    else if (!strcmp(words[0],"autokill")) {
        mitm.opt.autokill = !mitm.opt.autokill;
        sprintf(reply,"Autokill is %s",mitm.opt.autokill?"enabled":"disabled");
    }
    else if (!strcmp(words[0],"grind")) {
        int maxlevel=30;
        int start = 1;

        if (words[1]) {
            if (!strcmp(words[1],"stop")) {
                mitm.opt.grinding = 0;
                mitm.opt.autokill = 0;
                sprintf(reply,"Grinding is stopped");
                start = 0;
            }
            else if (sscanf(words[1],"%d",&maxlevel)!=1) {
                maxlevel = 30;
            }
        }

        if (start) {
            mitm.opt.grinding = 1;
            mitm.opt.autokill = 1;
            mitm.opt.maxlevel = maxlevel;
            sprintf(reply,"Grinding to level %d",mitm.opt.maxlevel);
        }
    }
    else if (!strcmp(words[0],"ft")) {
        int ll = 119;
        int lh = 122;
        int error = 0;
        if (words[1]) {
            if (sscanf(words[1],"%d",&ll)!=1)
                error++;

            if (words[2]) {
                if (sscanf(words[2],"%d",&lh)!=1)
                    error++;
            }
        }

        if (ll<0 || lh<0 || lh<ll || lh>((gs.current_dimension==DIM_NETHER)?126:254))
            error++;

        if (error)
            sprintf(reply, "incorrect level range specified");
        else
            find_tunnels(retour,ll,lh);
    }
    else if (!strcmp(words[0],"map")) {
        int error=0;
        int y = gs.own.y>>5;

        if (words[1]) {
            if (sscanf(words[1],"%d",&y)!=1)
                error++;
        }

        if (error) {
            sprintf(reply, "incorrect level specified");
        }
        else {
            int xp = gs.own.x>>5;
            int zp = gs.own.z>>5;
            int X = gs.own.x>>9;
            int Z = gs.own.z>>9;
            uint8_t *map = export_cuboid(X-5,X+5,Z-5,Z+5,y,y);

            int xoff = (X-5)*16;
            int zoff = (Z-5)*16;

            int x,z;
            printf("MAP x=%d:%d z=%d:%d y=%d\n",(X-5)*16,(X+6)*16-1,(Z-5)*16,(Z+6)*16-1,y);
            for(z=(5*16); z<(7*16); z++) {
                uint8_t * p = map+z*(11*16)+5*16;
                printf("%s%6d  ",ANSI_CLEAR,z);
                for(x=(5*16); x<(7*16); x++,p++) {
                    if (x+xoff==xp && z+zoff==zp)
                        printf("%s",ANSI_PLAYER);
                    else
                        printf("%s",ANSI_BLOCK[*p]);
                }
                printf("%s\n",ANSI_CLEAR);
            }
            free(map);
        }
    }
    else if (!strcmp(words[0],"build")) {
        build_request(words, retour);
    }
    else if (!strcmp(words[0],"salt")) {
        int x,y,z;
        if (!words[1] || !words[2] || !words[3] || 
            sscanf(words[1],"%d",&x)!=1 || 
            sscanf(words[2],"%d",&y)!=1 || 
            sscanf(words[3],"%d",&z)!=1 ) {
            sprintf(reply, "Usage: #salt x y z");
        }
        salt_request(x,y,z);
        
    }
    else if (!strcmp(words[0],"holeradar")) {
        mitm.opt.holeradar = !mitm.opt.holeradar;
        sprintf(reply,"Hole radar is %s",mitm.opt.holeradar?"enabled":"disabled");
    }

    if (reply[0])
        chat_message(reply, retour, NULL);

    return 1;
}

////////////////////////////////////////////////////////////////////////////////

#include "ids.h"

void process_encryption_request(uint8_t *p, lh_buf_t *forw) {
    Rstr(serverID);

    Rshort(klen);
    memmove(mitm.s_pkey,p,klen);
    Rskip(klen);

    Rshort(tlen);
    memmove(mitm.s_token,p,tlen);
    Rskip(tlen);

    printf("Encryption Request\n");
                
    sprintf(mitm.s_id,"%s",serverID);
    mitm.s_pklen = klen;
                
    // decode server PUBKEY to an RSA struct
    unsigned char *pp = mitm.s_pkey;
    d2i_RSA_PUBKEY(&mitm.s_rsa, (const unsigned char **)&pp, klen);
    if (mitm.s_rsa == NULL) {
        printf("Failed to decode the server's public key\n");
        exit(1);
    }
    RSA_print_fp(stdout, mitm.s_rsa, 4);

    // generate the server-side shared key pair
    RAND_pseudo_bytes(mitm.s_skey, 16);
    printf("Server-side shared key: ");
    hexprint(mitm.s_skey, 16);

    // create a client-side RSA
    mitm.c_rsa = RSA_generate_key(1024, RSA_F4, NULL, NULL);
    if (mitm.c_rsa == NULL) {
        printf("Failed to generate client-side RSA key\n");
        exit(1);
    }
    RSA_print_fp(stdout, mitm.c_rsa, 4);
    
    // encode the client-side pubkey as DER
    pp = mitm.c_pkey;
    mitm.c_pklen = i2d_RSA_PUBKEY(mitm.c_rsa, &pp);

    // generate the client-side verification token
    RAND_pseudo_bytes(mitm.c_token, 4);

    // combine it to a MCP message to the client
    uint8_t output[65536];
    uint8_t *w = output;

    write_varint(w, PID(SL_EncryptionRequest));
    write_varint(w, strlen(serverID));
    memmove(w, serverID, strlen(serverID));
    w+=strlen(serverID);
    write_short(w, mitm.c_pklen);
    memmove(w, mitm.c_pkey, mitm.c_pklen);
    w+=mitm.c_pklen;
    write_short(w, 4);
    memmove(w, mitm.c_token, 4);
    w+=4;
    
    write_packet(output, w-output, forw);
}

void process_encryption_response(uint8_t *p, lh_buf_t *forw) {
    Rshort(sklen);
    uint8_t *skey = p;
    Rskip(sklen);
    Rshort(tklen);
    uint8_t *token = p;
    Rskip(tklen);

    char buf[4096];
    int dklen = RSA_private_decrypt(sklen, skey, buf, mitm.c_rsa, RSA_PKCS1_PADDING);
    if (dklen < 0) {
        printf("Failed to decrypt the shared key received from the client\n");
        exit(1);
    }
    printf("Decrypted client shared key, keylen=%d ",dklen);
    hexprint(buf, dklen);
    memcpy(mitm.c_skey, buf, 16);
    
    int dtlen = RSA_private_decrypt(tklen, token, buf, mitm.c_rsa, RSA_PKCS1_PADDING);
    if (dtlen < 0) {
        printf("Failed to decrypt the verification token received from the client\n");
        exit(1);
    }
    printf("Decrypted client token, len=%d ",dtlen);
    hexprint(buf, dtlen);
    printf("Original token: ");
    hexprint(mitm.c_token,4);
    if (memcmp(buf, mitm.c_token, 4)) {
        printf("Token does not match!\n");
        exit(1);
    }
            
    uint8_t output[65536];
    uint8_t *w = output;

    // at this point, the client side is verified and the key is established
    // now send our response to the server
    write_varint(w, PID(CL_EncryptionResponse));

    int eklen = RSA_public_encrypt(sizeof(mitm.s_skey), mitm.s_skey, buf, mitm.s_rsa, RSA_PKCS1_PADDING);
    write_short(w,(short)eklen);
    memcpy(w, buf, eklen);
    w += eklen;
            
    int etlen = RSA_public_encrypt(sizeof(mitm.s_token), mitm.s_token, buf, mitm.s_rsa, RSA_PKCS1_PADDING);
    write_short(w,(short)etlen);
    memcpy(w, buf, etlen);
    w += etlen;
                
    query_auth_server();
    hexdump(output, w-output);
    write_packet(output, w-output, forw);

    mitm.enable_encryption = 1;
}

void process_packet(int is_client, uint8_t *ptr, ssize_t len,
                    lh_buf_t *forw, lh_buf_t *retour) {

    // one nice advantage - we can be sure that we have all data in the buffer,
    // so there's no need for limit checking with the new protocol

    if (mitm.output) {
        // write packet to the MCS file
        struct timeval tv;
        gettimeofday(&tv, NULL);

        uint8_t header[4096];
        uint8_t *hp = header;
        write_int(hp, is_client);
        write_int(hp, tv.tv_sec);
        write_int(hp, tv.tv_usec);
        write_int(hp, len);
        fwrite(header, 1, hp-header, mitm.output);
        fwrite(ptr, 1, len, mitm.output);
        fflush(mitm.output);
    }

    uint8_t *p = ptr;
    uint32_t type = lh_read_varint(p);
    uint32_t stype = ((mitm.state<<24)|(is_client<<28)|(type&0xffffff));

    char *states = "ISLP";

#if 0
    printf("%c %c type=%02x, len=%zd\n", is_client?'C':'S',
           states[mitm.state],type,len);
    hexdump(ptr, len);
#endif

    uint8_t output[65536];
    uint8_t *w = output;

    if (mitm.state == STATE_PLAY)
        import_packet(ptr, len, is_client);

    switch (stype) {
        ////////////////////////////////////////////////////////////////////////
        // Idle state

        case CI_Handshake: {
            Rvarint(protocolVer);
            Rstr(serverAddr);
            Rshort(serverPort);
            Rvarint(nextState);
            mitm.state = nextState;
            printf("C %-30s protocol=%d server=%s:%d nextState=%d\n",
                   "Handshake",protocolVer,serverAddr,serverPort,nextState);
            write_packet(ptr, len, forw);
            break;
        }

        ////////////////////////////////////////////////////////////////////////
        // Login

        case CL_EncryptionResponse:
            process_encryption_response(p, forw);
            break;

        case SL_EncryptionRequest:
            process_encryption_request(p, forw);
            break;

        ////////////////////////////////////////////////////////////////////////
        // Play

        case SP_SpawnPlayer: {
            Rvarint(eid);
            Rstr(uuid);
            Rstr(name);
            Rint(x);
            Rint(y);
            Rint(z);
            Rchar(yaw);
            Rchar(pitch);
            Rshort(item);
            //TODO: metadata

            char msg[32768];
            sprintf(msg, "Player %s at %d,%d,%d",name,x>>5,y>>5,z>>5);
            chat_message(msg, forw, "blue");
            write_packet(ptr, len, forw);
            break;
        }

        case SP_SoundEffect: {
            Rstr(name);
            Rint(x);
            Rint(y);
            Rint(z);
            Rfloat(volume);
            Rchar(pitch);
            if (!strcmp(name,"ambient.weather.thunder")) {
                printf("**** THUNDER ****\n"
                       "coords=%d,%d,%d vol=%.4f pitch=%d\n",
                       x/8,y/8,z/8,volume,pitch);
                close(mitm.ms);
            }
            if (strcmp(name,"mob.sheep.say") && strcmp(name,"mob.sheep.step"))
                write_packet(ptr, len, forw);
            break;
        }

        case SP_Effect: {
            Rint(efid);
            Rint(x);
            Rchar(y);
            Rint(z);
            Rint(data);
            Rchar(disrv);
            if (efid == 1013) {
                printf("**** Wither Spawn ****  efid=%d data=%d bcoord=%d:%d:%d %s\n",
                       efid,data,x,y,z,disrv?"disable relative volume":"");
            }
            write_packet(ptr, len, forw);
            break;
        }

        case SP_SetExperience: {
            Rfloat(bar);
            Rshort(level);
            Rshort(exp);

            if (mitm.opt.grinding && level >= mitm.opt.maxlevel) {
                mitm.opt.grinding = 0;
                mitm.opt.autokill = 0;

                char msg[4096];
                sprintf(msg, "Grinding finished at level %d",level);
                chat_message(msg, forw, "green");                
            }
            write_packet(ptr, len, forw);
            break;
        }

        case SP_PlayerPositionLook:
        case CP_PlayerPositionLook:
        case CP_PlayerPosition:
        case CP_PlayerLook:
        case SP_MultiBlockChange:
        case SP_BlockChange: {
            if (mitm.opt.holeradar) {
                int x = gs.own.x>>5;
                int y = gs.own.y>>5;
                int z = gs.own.z>>5;
                int yaw = (int)gs.own.yaw/90;

                if (x!= mitm.hr_last_x || y!= mitm.hr_last_y || 
                    z!= mitm.hr_last_z || yaw!= mitm.hr_last_yaw ) {
                    mitm.hr_last_x = x;
                    mitm.hr_last_y = y;
                    mitm.hr_last_z = z;
                    mitm.hr_last_yaw = yaw;
                    hole_radar(is_client?retour:forw);
                }
            }
            if (mitm.opt.build) {
                build_process(is_client?retour:forw);
            }

            write_packet(ptr, len, forw);
            break;
        }

        case CP_ChatMessage: {
            Rstr(msg);
            if (msg[0] == '#') {
                if (process_message(msg, forw, retour))
                    break;
            }

            // if it was a normal chat message, just forward it
            write_packet(ptr, len, forw);
            break;
        }

        ////////////////////////////////////////////////////////////////////////
        default: {
            // by default, just forward the packet as is
            write_packet(ptr, len, forw);
        }
    }

}

ssize_t handle_proxy(lh_conn *conn) {
    int is_client = (conn->priv != NULL);

    if (conn->status&CONN_STATUS_REMOTE_EOF) {
        // one of the parties has closed the connection.
        // close both sides, deinit the MITM state and
        // remove our descriptors from the pollarray

        close(mitm.cs);
        close(mitm.ms);
        mitm.state = STATE_IDLE;
        mitm.cs = mitm.ms = -1;
        lh_conn_remove(mitm.cs_conn);
        lh_conn_remove(mitm.ms_conn);

        return 0;
    }

    // determine decoded buffers for input (rx), output (tx) and retour (bx)
    lh_buf_t *rx = is_client ? &mitm.cs_rx : &mitm.ms_rx;
    lh_buf_t *tx = is_client ? &mitm.cs_tx : &mitm.ms_tx;
    lh_buf_t *bx = is_client ? &mitm.ms_tx : &mitm.cs_tx;

    assert(conn->rbuf.P(data));

    // sptr,slen - pointer and length of data in the receive buffer
    ssize_t slen = conn->rbuf.C(data) - conn->rbuf.ridx;
    uint8_t *sptr = conn->rbuf.P(data) + conn->rbuf.ridx;

    // provide necessary space in the decoded receive buffer
    ssize_t widx = rx->C(data);
    lh_arr_add(GAR4(rx->data),slen);

#if 0
    printf("*** network data %s ***\n",is_client?"C->S":"C<-S");
    hexdump(sptr, slen);
    printf("************************\n");
#endif

    if (mitm.state == STATE_PLAY) {
        // decryption needed
        int num = 0;
        if (is_client)
            AES_cfb8_encrypt(sptr, rx->P(data)+widx, slen,
                             &mitm.c_aes, mitm.c_dec_iv, &num, AES_DECRYPT);
        else
            AES_cfb8_encrypt(sptr, rx->P(data)+widx, slen,
                             &mitm.s_aes, mitm.s_dec_iv, &num, AES_DECRYPT);
    }
    else {
        // plaintext communication
        memmove(rx->P(data)+widx, sptr, slen);
    }

#if 0
    printf("*** decrypted data %s ***\n",is_client?"C->S":"C<-S");
    hexdump(rx->P(data), rx->C(data));
    printf("************************\n");
#endif

    //assert(bx->C(data)==0);

    // try to extract as many packets from the stream as we can in a loop
    while(rx->C(data) > 0) {
        //hexdump(AR(rx->data));
        // do we have a complete packet?
        uint8_t *p = rx->P(data);

        // large varint, data is definitely too short
        if (((*p)&0x80)&&(rx->C(data)<129)) break;

        uint32_t plen = lh_read_varint(p);
        ssize_t ll = p-rx->P(data); // length of the varint
        if (plen+ll > rx->C(data)) break; // packet is incomplete

        process_packet(is_client, p, plen, tx, bx);
        lh_arr_delete_range(GAR4(rx->data),0,ll+plen);
    }

    if (tx->C(data) > 0) {
        if (mitm.state == STATE_PLAY) {
            // since we always write out all data, we just encrypt this in-place
            int num=0;
            if (is_client)
                AES_cfb8_encrypt(tx->P(data), tx->P(data), tx->C(data),
                                 &mitm.s_aes, mitm.s_enc_iv, &num, AES_ENCRYPT);
            else
                AES_cfb8_encrypt(tx->P(data), tx->P(data), tx->C(data),
                                 &mitm.c_aes, mitm.c_enc_iv, &num, AES_ENCRYPT);
        }
        
        lh_conn_write(is_client?mitm.ms_conn:mitm.cs_conn, AR(tx->data));
        tx->C(data) = tx->ridx = 0;
    }
    
    if (bx->C(data) > 0) {
        if (mitm.state == STATE_PLAY) {
            // since we always write out all data, we just encrypt this in-place
            int num=0;
            if (is_client)
                AES_cfb8_encrypt(bx->P(data), bx->P(data), bx->C(data),
                                 &mitm.c_aes, mitm.c_enc_iv, &num, AES_ENCRYPT);
            else
                AES_cfb8_encrypt(bx->P(data), bx->P(data), bx->C(data),
                                 &mitm.s_aes, mitm.s_enc_iv, &num, AES_ENCRYPT);
        }
        lh_conn_write(is_client?mitm.cs_conn:mitm.ms_conn, AR(bx->data));
        bx->C(data) = bx->ridx = 0;
    }
    
    if (mitm.enable_encryption) {
        // init the encryption
        // this is delayed so the last packet (CL_EncryptionResponse) can go out unencrypted
        AES_set_encrypt_key(mitm.c_skey, 128, &mitm.c_aes);
        memcpy(mitm.c_enc_iv, mitm.c_skey, 16);
        memcpy(mitm.c_dec_iv, mitm.c_skey, 16);

        AES_set_encrypt_key(mitm.s_skey, 128, &mitm.s_aes);
        memcpy(mitm.s_enc_iv, mitm.s_skey, 16);
        memcpy(mitm.s_dec_iv, mitm.s_skey, 16);

        printf("c_skey:   "); hexdump(mitm.c_skey,16);
        printf("c_enc_iv: "); hexdump(mitm.c_enc_iv,16);
        printf("c_dec_iv: "); hexdump(mitm.c_dec_iv,16);
        printf("s_skey:   "); hexdump(mitm.s_skey,16);
        printf("s_enc_iv: "); hexdump(mitm.s_enc_iv,16);
        printf("s_dec_iv: "); hexdump(mitm.s_dec_iv,16);

        mitm.state = STATE_PLAY;
        mitm.enable_encryption=0;
    }

    return slen;
}

////////////////////////////////////////////////////////////////////////////////

#define MAX_ENTITIES     4096
#define MAX_ATTACK       1
#define MIN_ENTITY_DELAY 250000  // minimum interval between hitting the same entity (us)
#define MIN_ATTACK_DELAY  50000  // minimum interval between attacking any entity
#define MIN_BUILD_DELAY  200000

int is_hostile_entity(entity *e) {
    return e->hostile > 0;
}

int handle_async() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    uint64_t ts = (uint64_t)tv.tv_sec*1000000+(uint64_t)tv.tv_usec;

    // Auto Kill
    if (mitm.opt.autokill && (ts-gs.last_attack)>MIN_ATTACK_DELAY ) {
        // calculate list of hostile entities in range
        int hent[MAX_ENTITIES];

        //TODO: sort entities by how dangerous and how close they are
        int nhent = get_entities_in_range(hent,MAX_ENTITIES,5.0,is_hostile_entity,NULL);

        //if (nhent > 0) printf("%s : got %d entities to kill\n",__func__,nhent);

        //TODO: select primary weapon for priority targets

        //TODO: turn to target?

        int i,h;
        for(i=0,h=0; h<MAX_ATTACK && i<nhent; i++) {
            entity *e = gs.P(entity)+hent[i];
            if ((ts-e->lasthit) < MIN_ATTACK_DELAY)
                continue;

            uint8_t pkt[4096], *p;

            //printf("%lld : Attack entity %d\n", ts, e->id);

            // attack entity
            p = pkt;
            write_varint(p,0x02); // Use Entity
            write_int(p, e->id);
            write_char(p, 0x01);
            write_packet(pkt, p-pkt, &mitm.cs_tx);

            // wave arm
            p = pkt;
            write_varint(p,0x0a); // Animation
            write_int(p,gs.own.id);
            write_char(p,0x01);
            write_packet(pkt, p-pkt, &mitm.cs_tx);

            e->lasthit = ts;
            gs.last_attack = ts;
            h++;
        }
    }

    // Autobuild
    if (C(mitm.build.inreach)>0 && (ts-mitm.build.last_placement)>MIN_BUILD_DELAY ) {
        int idx = random()%C(mitm.build.inreach);

        bblock *bb = P(mitm.build.inreach)+idx;

        printf("Placing at %d,%d,%d\n",bb->x,bb->y,bb->z);
        
        uint8_t pkt[4096], *p;
        
        // place block
        p = pkt;
        write_varint(p,0x08); // PlayerBlockPlacement

        switch (bb->dir) {
            case 0: //UP
                write_int(p,bb->x);         
                write_char(p,(char)bb->y+1);
                write_int(p,bb->z);
                break;
            case 1: //DOWN
                write_int(p,bb->x);         
                write_char(p,(char)bb->y-1);
                write_int(p,bb->z);
                break;
            case 2: //SOUTH
                write_int(p,bb->x);         
                write_char(p,(char)bb->y);
                write_int(p,bb->z+1);
                break;
            case 3: //NORTH
                write_int(p,bb->x);         
                write_char(p,(char)bb->y);
                write_int(p,bb->z-1);
                break;
            case 4: //EAST
                write_int(p,bb->x+1);         
                write_char(p,(char)bb->y);
                write_int(p,bb->z);
                break;
            case 5: //WEST
                write_int(p,bb->x-1);         
                write_char(p,(char)bb->y);
                write_int(p,bb->z);
                break;
        }

        write_char(p,bb->dir);      // direction

        // TODO: take slot data from the appropriate slot

#if 0
        write_short(p,87);          // netherrack
        write_char(p,1);            // count
        write_short(p,0);           // damage
#endif
        write_short(p,0xffff);      // no data

        int cx = bb->cx; //if (cx==8) cx+=((random()%7)-4);
        int cy = bb->cy; //if (cy==8) cy+=((random()%7)-4);
        int cz = bb->cz; //if (cz==8) cz+=((random()%7)-4);

        write_char(p,cx);       // cursor position
        write_char(p,cy);       
        write_char(p,cz);        
        write_packet(pkt, p-pkt, &mitm.cs_tx);

        // wave arm
        p = pkt;
        write_varint(p,0x0a); // Animation
        write_int(p,gs.own.id);
        write_char(p,0x01);
        write_packet(pkt, p-pkt, &mitm.cs_tx);

        mitm.build.last_placement = ts;
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// Session Server

#if 0
//POST /session/minecraft/join HTTP/1.1
//Content-Type: application/json; charset=utf-8
//Cache-Control: no-cache
//Pragma: no-cache
//User-Agent: Java/1.6.0_27
//Host: ssessionserver.mojang.com
//Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
//Connection: keep-alive
//Content-Length: 156

//{"accessToken":"bbc3cae3264e4ad0b446fd9bb852519a","selectedProfile":"962c6718688448d4a35c249f8d30428b","serverId":"bd651042ec97910e449e11a3991e1274e3e67e5"}HTTP/1.1 401 Authorization Required

//HTTP/1.1 204 No Content                                                                                                    
//Accept-Ranges: bytes                                                                                                       
//Content-length: 0                                                                                                                     
//Date: Mon, 21 Apr 2014 13:13:54 GMT                                                                                                   
//Server: Restlet-Framework/2.2.0                                                                                                       
//Connection: keep-alive                                                                                                                
                                                                                                                                             
#endif

int parseJson(const char *buf, const char *str, char *dst, ssize_t size) {
    const char *name = strstr(buf, str);
    if (!name) return 0;

    while(*name != ':') name++;
    while(*name != '"') name++;
    name++; // now it points to the start of the value

    char *d = dst;
    while(*name != '"' && ((d-dst)<(size-1))) { *d++ = *name++; }
    *d = 0;

    return 1;
}

int handle_session_server(int sfd) {
    // accept connection from the client side
    struct sockaddr_in cadr;
    int cs = lh_accept_tcp4(sfd, &cadr);
    lh_net_blocking(cs);
    if (cs < 0)
        LH_ERROR(0, "Failed to accept the client-side connection");
    printf("Accepted from %s:%d (Webserver)\n",
           inet_ntoa(cadr.sin_addr),ntohs(cadr.sin_port));

    // create a stream connection
    FILE *fp = fdopen(cs,"r+");
    if (!fp) {
        close(cs);
        LH_ERROR(0, "Failed to create a stream connection");
    }

    // read the header
    int clen = 0;
    char buf[262144];
    while(1) {
        if (!fgets(buf, sizeof(buf), fp)) {
            fclose(fp);
            LH_ERROR(0, "Failed to read the header");
        }

        printf(">%s<\n",buf);

        if (!memcmp(buf, "\r\n\0", 3))
            break;

        if (sscanf(buf, "Content-Length: %u", &clen)==1)
            printf("parsed the content length : %d\n",clen);
    }
    printf("parsed the header completely\n");

    // read the POST body
    fread(buf, 1, clen, fp);

    hexdump(buf, clen);
    buf[clen] = 0;
    printf(">%s<\n",buf);

    // parse the JSON (Q&D)
    if ( ! (
            parseJson(buf,"accessToken",mitm.accessToken,sizeof(mitm.accessToken))&&
            parseJson(buf,"selectedProfile",mitm.selectedProfile,sizeof(mitm.selectedProfile))&&
            parseJson(buf,"serverId",mitm.serverId,sizeof(mitm.serverId))
            )) {
        fclose(fp);
        LH_ERROR(0, "Failed to parse JSON");
    }

    printf("accessToken:     >%s<\n",mitm.accessToken);
    printf("selectedProfile: >%s<\n",mitm.selectedProfile);
    printf("serverId:        >%s<\n",mitm.serverId);


    // send response
    time_t ts;
    time(&ts);
    fprintf(fp,
            "HTTP/1.1 204 No Content\r\n"
            "Accept-Ranges: bytes\r\n"
            "Content-length: 0\r\n"
            "Date: %s\r\n"
            "Server: Restlet-Framework/2.2.0\r\n"
            "Connection: keep-alive\r\n"
            "\r\n",asctime(gmtime(&ts)));
    fflush(fp);
    fclose(fp);
    return 1;
}

void print_hex(char *buf, const char *data, ssize_t len) {
    int i;
    char *w = buf;
    int f = 0;
    if (data[0] < 0) {
        *w++ = '-';
        f = 1;
    }
    for(i=0; i<len; i++) {
        char d = data[i];
        if (f) {
            d = -d;
            if (i<len-1)
                d--;
        }
        
        sprintf(w,"%02x",(unsigned char)d);
        w+=2;
    }

    *w++ = 0;

    w = buf+f;
    char *z = w;
    while(*z == '0') z++;
    while(*z) *w++ = *z++;
    *w++ = 0;
}

int query_auth_server() {
    // the final touch - send the authentication token to the session server
    unsigned char md[SHA_DIGEST_LENGTH];
    SHA_CTX sha; CLEAR(sha);
    
    SHA1_Init(&sha);
    SHA1_Update(&sha, mitm.s_id, strlen(mitm.s_id));
    SHA1_Update(&sha, mitm.s_skey, sizeof(mitm.s_skey));
    SHA1_Update(&sha, mitm.s_pkey, mitm.s_pklen);
    SHA1_Final(md, &sha);
    
    char auth[4096];
    hexdump(md, SHA_DIGEST_LENGTH);
    print_hex(auth, md, SHA_DIGEST_LENGTH);
    printf("sessionId : %s\n", auth);

    char buf[4096];
    sprintf(buf,"{\"accessToken\":\"%s\",\"selectedProfile\":\"%s\",\"serverId\":\"%s\"}",
            mitm.accessToken, mitm.selectedProfile, auth);

    // perform a request with a cURL client

    CURL *curl = curl_easy_init();
    CURLcode res;

    // set header options
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_easy_setopt(curl, CURLOPT_URL, "https://sessionserver.mojang.com/session/minecraft/join");
    curl_easy_setopt(curl, CURLOPT_USERAGENT, "Java/1.6.0_27");
    
    struct curl_slist *headerlist=NULL;
    headerlist = curl_slist_append(headerlist, "Content-Type: application/json; charset=utf-8");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);

    // set body - our JSON blob
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, buf);

    // make a request
    res = curl_easy_perform(curl);
    if(res != CURLE_OK)
        fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
 
    curl_easy_cleanup(curl);
    curl_global_cleanup();

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
// Minecraft client connections

int handle_server(int sfd, uint32_t ip, uint16_t port) {
    // accept connection from the local client
    struct sockaddr_in cadr;
    int cs = lh_accept_tcp4(sfd, &cadr);
    if (cs < 0)
        LH_ERROR(0, "Failed to accept the client-side connection");

    printf("Accepted from %s:%d\n",
           inet_ntoa(cadr.sin_addr),ntohs(cadr.sin_port));
    
    // open connection to the remote server
    int ms = lh_connect_tcp4(ip, port);
    if (ms < 0) {
        close(mitm.cs);
        LH_ERROR(0, "Failed to open the client-side connection");
    }

    // TCP connections established, 
    printf("New connection: cs=%d ms=%d\n", cs, ms);
    
    // initialize mitm struct, terminate old state if any
    if (mitm.output) fclose(mitm.output);
    if (mitm.dbg)    fclose(mitm.dbg);
    if (mitm.s_rsa) RSA_free(mitm.s_rsa);
    if (mitm.c_rsa) RSA_free(mitm.c_rsa);
    CLEAR(mitm);

    reset_gamestate();
    set_option(GSOP_PRUNE_CHUNKS, 1);
    set_option(GSOP_SEARCH_SPAWNERS, 1);
    set_option(GSOP_TRACK_ENTITIES, 1);

    char fname[4096];
    time_t t;
    time(&t);
    strftime(fname, sizeof(fname), "saved/%Y%m%d_%H%M%S.mcs",localtime(&t));
    mitm.output = fopen(fname, "w");
    setvbuf(mitm.output, NULL, _IONBF, 0);
    //strftime(fname, sizeof(fname), "saved/%Y%m%d_%H%M%S.dbg",localtime(&t));
    //mitm.dbg = fopen(fname, "w");
    //setvbuf(mitm.dbg, NULL, _IONBF, 0);

    // handle_server was able to accept the client connection and
    // also open the server-side connection, we need to add these
    // new sockets to the groups cg and mg respectively
    mitm.cs = cs;
    mitm.ms = ms;
    mitm.cs_conn = lh_conn_add(&pa, cs, G_PROXY, (void*)1);
    mitm.ms_conn = lh_conn_add(&pa, ms, G_PROXY, (void*)0);

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
// Main loop

int proxy_pump(uint32_t ip, uint16_t port) {
    CLEAR(pa);

    CLEAR(mitm);
    mitm.cs = mitm.ms = -1;

    // Minecraft proxy server
    int ss = lh_listen_tcp4_any(port);
    if (ss<0) return -1;
    lh_poll_add(&pa, ss, POLLIN, G_MCSERVER, NULL);

    // fake session.minecraft.com web server
    int ws = lh_listen_tcp4_any(WEBSERVER_PORT);
    if (ws<0) return -1;
    lh_poll_add(&pa, ws, POLLIN, G_WEBSERVER, NULL);

    // prepare signal handling
    signal_caught = 0;
    struct sigaction sa;
    CLEAR(sa);
    sa.sa_handler = signal_handler;
    if (sigaction(SIGINT, &sa, NULL))
        LH_ERROR(1,"Failed to set sigaction\n");

    // main pump
    int i;
    while(!signal_caught) {
        lh_poll(&pa, 1000);

        lh_polldata *pd;
        int pos;

        // handle connection requests on the web server
        if ( pd=lh_poll_getfirst(&pa, G_WEBSERVER, POLLIN))
            handle_session_server(pd->fd);

        if ( pd=lh_poll_getfirst(&pa, G_MCSERVER, POLLIN))
            handle_server(pd->fd, ip, port);

        // handle client- and server-side connection
        lh_conn_process(&pa, G_PROXY, handle_proxy);

        // handle asynchronous events
        if (mitm.state == STATE_PLAY)
            handle_async();
    }

    printf("Terminating...\n");
    if (mitm.output) {
        fflush(mitm.output);
        fclose(mitm.output);
        mitm.output = NULL;
    }
    if (mitm.dbg) {
        fclose(mitm.dbg);
        mitm.dbg = NULL;
    }
}

int main(int ac, char **av) {
    uint32_t server_ip = lh_dns_addr_ipv4(av[1]?av[1]:SERVER_ADDR);
    if (server_ip == 0xffffffff)
        LH_ERROR(-1, "Failed to obtain IP address for the server %s",SERVER_ADDR);
        
    proxy_pump(server_ip, SERVER_PORT);

    return 0;
}
