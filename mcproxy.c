#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <sys/socket.h>
#include <signal.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <time.h>

#include <openssl/rsa.h>
#include <openssl/x509.h>
#include <openssl/sha.h>
#include <openssl/aes.h>

#define LH_DECLARE_SHORT_NAMES 1

#include "lh_debug.h"
#include "lh_buffers.h"
#include "lh_bytes.h"
#include "lh_files.h"
#include "lh_net.h"
#include "lh_event.h"
#include "lh_compress.h"
#include "lh_arr.h"

#include "gamestate.h"

#define SERVER_ADDR "2b2t.org"

#define SERVER_PORT 25565
#define WEBSERVER_PORT 8080

#define ASYNC_THRESHOLD 500000
#define NEAR_THRESHOLD 40000

#define G_MCSERVER  1
#define G_WEBSERVER 2
#define G_PROXY     3

#define STATE_IDLE     0
#define STATE_STATUS   1
#define STATE_LOGIN    2
#define STATE_PLAY     3

////////////////////////////////////////////////////////////////////////////////

int signal_caught;

void signal_handler(int signum) {
    printf("Caught signal %d, stopping main loop\n",signum);
    signal_caught = 1;
}

////////////////////////////////////////////////////////////////////////////////

lh_pollarray pa;

struct {
    int state;          // handshake state

    int cs;             // connected socket to client
    int ms;             // connected socket to server

    // connections
    lh_conn * cs_conn; // to the client
    lh_conn * ms_conn; // to the server

    // decoded buffers
    lh_buf_t  cs_rx;   // client -> proxy
    lh_buf_t  cs_tx;   // proxy -> client
    lh_buf_t  ms_rx;   // server -> proxy
    lh_buf_t  ms_tx;   // proxy -> server

    // RSA structures/keys for server-side and client-side
    RSA *s_rsa; // public key only - must be freed by RSA_free
    RSA *c_rsa; // public+private key - must be freed by RSA_free

    // verification tokens
    char s_token[4]; // what we received from the server
    char c_token[4]; // generated by us, sent to client

    // AES encryption keys (128 bit)
    char s_skey[16]; // generated by us, sent to the server
    char c_skey[16]; // received from the client

    // data parsed from JSON
    char accessToken[256];
    char selectedProfile[256];
    char serverId[256];

    // server ID - we forward this to client as is, so no need
    // for client- and server side versions.
    // zero-terminated string, so no need for length value
    // Note: serverID is received as UTF-16 string, but converted to ASCII
    // for hashing. The string itself is a hexstring, but it's not converted
    // to bytes or anything
    char s_id[256];

    // DER-encoded public key from the server
    char s_pkey[1024];
    int s_pklen;

    // DER-encoded public key sent to the client
    char c_pkey[1024];
    int c_pklen;

    int encstate;
    int passfirst;

    AES_KEY c_aes;
    char c_enc_iv[16];
    char c_dec_iv[16];

    AES_KEY s_aes;
    char s_enc_iv[16];
    char s_dec_iv[16];

    int enable_encryption;

    FILE * output;
    FILE * dbg;

    // Various options
    struct {
        int autokill;
        int cowradar;
        int grinding;
        int maxlevel;
    } opt;

    int64_t last[2];
} mitm;

////////////////////////////////////////////////////////////////////////////////

void write_packet(uint8_t *ptr, ssize_t len, lh_buf_t *buf) {
    uint8_t hbuf[16]; CLEAR(hbuf);
    ssize_t ll = lh_place_varint(hbuf,len) - hbuf;

    ssize_t widx = buf->C(data);
    if (mitm.dbg)
        fprintf(mitm.dbg, "%s:%d buf=%p ptr=%16p cnt=%zd adding %zd\n",
                __func__,__LINE__,buf,AR(buf->data),(len+ll));
    
    lh_arr_add(GAR4(buf->data),(len+ll));
    if (mitm.dbg)
        fprintf(mitm.dbg, "%s:%d buf=%p ptr=%16p cnt=%zd\n",
                __func__,__LINE__,buf,AR(buf->data));

    memmove(P(buf->data)+widx, hbuf, ll);
    memmove(P(buf->data)+widx+ll, ptr, len);
}

uint8_t * read_string(uint8_t *p, char *s) {
    uint32_t len = lh_read_varint(p);
    memmove(s, p, len);
    s[len] = 0;
    return p+len;
}

#define Rx(n,type,fun) type n = lh_read_ ## fun ## _be(p);

#define Rchar(n)  Rx(n,uint8_t,char)
#define Rshort(n) Rx(n,uint16_t,short)
#define Rint(n)   Rx(n,uint32_t,int)
#define Rlong(n)  Rx(n,uint64_t,long);
#define Rfloat(n) Rx(n,float,float)
#define Rdouble(n) Rx(n,double,double)
#define Rstr(n)   char n[4096]; p=read_string(p,n)
#define Rskip(n)  p+=n;
#define Rvarint(n) uint32_t n = lh_read_varint(p);

////////////////////////////////////////////////////////////////////////////////

void chat_message(const char *str, lh_buf_t *buf, const char *color) {
    uint8_t jreply[32768];
    ssize_t jlen = sprintf(jreply,
                           "{"
                           "\"text\":\"[MCP] %s\","
                           "\"color\":\"%s\""
                           "}",str,color?color:"red");
    uint8_t wbuf[65536];
    uint8_t *wp = wbuf;
    write_varint(wp, 0x02);
    write_varint(wp, jlen);
    memcpy(wp,jreply,jlen);
    write_packet(wbuf, (wp-wbuf)+jlen, buf);
}

int process_message(const char *msg, lh_buf_t *forw, lh_buf_t *retour) {
    if (msg[0] != '#') return 0;

    // tokenize
    char *words[256];
    CLEAR(words);
    int w=0;

    char wbuf[4096];
    strncpy(wbuf, msg+1, sizeof(wbuf));
    char *wsave;

    char *wstr = wbuf;
    do {
        words[w++] = strtok_r(wstr, " ", &wsave);
        wstr = NULL;
    } while(words[w-1]);
    w--;

    if (w==0) return 0;


    uint8_t reply[32768];
    reply[0] = 0;

    if (!strcmp(words[0],"test")) {
        sprintf(reply,"Chat test response");
    }
    else if (!strcmp(words[0],"entities")) {
        sprintf(reply,"Tracking %zd entities",gs.C(entity));
    }
    else if (!strcmp(words[0],"autokill")) {
        mitm.opt.autokill = !mitm.opt.autokill;
        sprintf(reply,"Autokill is %s",mitm.opt.autokill?"enabled":"disabled");
    }

    if (reply[0])
        chat_message(reply, retour, NULL);

    return 1;
}

////////////////////////////////////////////////////////////////////////////////

#define CI(x) ((0x10<<24)|(0x##x))
#define SI(x) ((0x00<<24)|(0x##x))
#define CS(x) ((0x11<<24)|(0x##x))
#define SS(x) ((0x01<<24)|(0x##x))
#define CL(x) ((0x12<<24)|(0x##x))
#define SL(x) ((0x02<<24)|(0x##x))
#define CP(x) ((0x13<<24)|(0x##x))
#define SP(x) ((0x03<<24)|(0x##x))

// Handshakes

#define CI_Handshake            CI(00)

// Status Query

#define CS_Request              CS(00)
#define CS_PingRequest          CS(01)
#define SS_Response             SS(00)
#define SS_PingResponse         SS(01)

// Login Process

#define CL_LoginStart           CL(00)
#define CL_EncryptionResponse   CL(01)
#define SL_Disconnect           SL(00)
#define SL_EncryptionRequest    SL(01)
#define SL_LoginSuccess         SL(02)

// Play

#define SP_PlayerPositionLook   SP(08)
#define SP_SpawnPlayer          SP(0c)
#define SP_SpawnObject          SP(0e)
#define SP_SpawnMob             SP(0f)
#define SP_SpawnPainting        SP(10)
#define SP_SpawnExperienceOrb   SP(11)
#define SP_DestroyEntities      SP(13)
#define SP_Entity               SP(14)
#define SP_EntityRelMove        SP(15)
#define SP_EntityLook           SP(16)
#define SP_EntityLookRelMove    SP(17)
#define SP_EntityTeleport       SP(18)
#define SP_SetExperience        SP(1f)

#define SP_ChunkData            SP(21)
#define SP_MultiBlockChange     SP(22)
#define SP_BlockChange          SP(23)
#define SP_MapChunkBulk         SP(26)
#define SP_Effect               SP(28)
#define SP_SoundEffect          SP(29)

#define CP_ChatMessage          CP(01)

void process_packet(int is_client, uint8_t *ptr, ssize_t len,
                    lh_buf_t *forw, lh_buf_t *retour) {

    // one nice advantage - we can be sure that we have all data in the buffer,
    // so there's no need for limit checking with the new protocol

    if (mitm.output) {
        // write packet to the MCS file
        struct timeval tv;
        gettimeofday(&tv, NULL);

        uint8_t header[4096];
        uint8_t *hp = header;
        write_int(hp, is_client);
        write_int(hp, tv.tv_sec);
        write_int(hp, tv.tv_usec);
        write_int(hp, len);
        fwrite(header, 1, hp-header, mitm.output);
        fwrite(ptr, 1, len, mitm.output);
        fflush(mitm.output);
    }

    uint8_t *p = ptr;
    uint32_t type = lh_read_varint(p);
    uint32_t stype = ((mitm.state<<24)|(is_client<<28)|(type&0xffffff));

    char *states = "ISLP";

#if 0
    printf("%c %c type=%02x, len=%zd\n", is_client?'C':'S',
           states[mitm.state],type,len);
    hexdump(ptr, len);
#endif

    uint8_t output[65536];
    uint8_t *w = output;

    switch (stype) {
        ////////////////////////////////////////////////////////////////////////
        // Idle state

        case CI_Handshake: {
            Rvarint(protocolVer);
            Rstr(serverAddr);
            Rshort(serverPort);
            Rvarint(nextState);
            mitm.state = nextState;
            printf("C %-30s protocol=%d server=%s:%d nextState=%d\n",
                   "Handshake",protocolVer,serverAddr,serverPort,nextState);
            write_packet(ptr, len, forw);
            break;
        }

        ////////////////////////////////////////////////////////////////////////
        // Login

        case CL_EncryptionResponse: {
            Rshort(sklen);
            uint8_t *skey = p;
            Rskip(sklen);
            Rshort(tklen);
            uint8_t *token = p;
            Rskip(tklen);
            
            char buf[4096];
            int dklen = RSA_private_decrypt(sklen, skey, buf, mitm.c_rsa, RSA_PKCS1_PADDING);
            if (dklen < 0) {
                    printf("Failed to decrypt the shared key received from the client\n");
                    exit(1);
            }
            printf("Decrypted client shared key, keylen=%d ",dklen);
            hexprint(buf, dklen);
            memcpy(mitm.c_skey, buf, 16);
            
            int dtlen = RSA_private_decrypt(tklen, token, buf, mitm.c_rsa, RSA_PKCS1_PADDING);
            if (dtlen < 0) {
                    printf("Failed to decrypt the verification token received from the client\n");
                    exit(1);
            }
            printf("Decrypted client token, len=%d ",dtlen);
            hexprint(buf, dtlen);
            printf("Original token: ");
            hexprint(mitm.c_token,4);
            if (memcmp(buf, mitm.c_token, 4)) {
                printf("Token does not match!\n");
                    exit(1);
            }
            
            // at this point, the client side is verified and the key is established
            // now send our response to the server
            write_varint(w, 0x01);

            int eklen = RSA_public_encrypt(sizeof(mitm.s_skey), mitm.s_skey, buf, mitm.s_rsa, RSA_PKCS1_PADDING);
            write_short(w,(short)eklen);
            memcpy(w, buf, eklen);
            w += eklen;
            
            int etlen = RSA_public_encrypt(sizeof(mitm.s_token), mitm.s_token, buf, mitm.s_rsa, RSA_PKCS1_PADDING);
            write_short(w,(short)etlen);
            memcpy(w, buf, etlen);
            w += etlen;
                
            LH_HERE;
            query_auth_server();
            LH_HERE;
            hexdump(output, w-output);
            write_packet(output, w-output, forw);
            mitm.enable_encryption = 1;
            LH_HERE;
            break;
        }

        case SL_EncryptionRequest: {
            Rstr(serverID);

            Rshort(klen);
            memmove(mitm.s_pkey,p,klen);
            Rskip(klen);

            Rshort(tlen);
            memmove(mitm.s_token,p,tlen);
            Rskip(tlen);
            printf("Encryption Request\n");
                
            sprintf(mitm.s_id,"%s",serverID);
            mitm.s_pklen = klen;
                
            LH_HERE;
            // decode server PUBKEY to an RSA struct
            unsigned char *pp = mitm.s_pkey;
            d2i_RSA_PUBKEY(&mitm.s_rsa, (const unsigned char **)&pp, klen);
            if (mitm.s_rsa == NULL) {
                printf("Failed to decode the server's public key\n");
                exit(1);
            }
            RSA_print_fp(stdout, mitm.s_rsa, 4);

            // generate the server-side shared key pair
            RAND_pseudo_bytes(mitm.s_skey, 16);
            printf("Server-side shared key: ");
            hexprint(mitm.s_skey, 16);

            // create a client-side RSA
            mitm.c_rsa = RSA_generate_key(1024, RSA_F4, NULL, NULL);
            if (mitm.c_rsa == NULL) {
                printf("Failed to generate client-side RSA key\n");
                exit(1);
            }
            RSA_print_fp(stdout, mitm.c_rsa, 4);

            // encode the client-side pubkey as DER
            pp = mitm.c_pkey;
            mitm.c_pklen = i2d_RSA_PUBKEY(mitm.c_rsa, &pp);

            // generate the client-side verification token
            RAND_pseudo_bytes(mitm.c_token, 4);

            LH_HERE;
            // combine it to a MCP message to the client
            write_varint(w, 0x01);
            write_varint(w, strlen(serverID));
            memmove(w, serverID, strlen(serverID));
            w+=strlen(serverID);
            write_short(w, mitm.c_pklen);
            memmove(w, mitm.c_pkey, mitm.c_pklen);
            w+=mitm.c_pklen;
            write_short(w, 4);
            memmove(w, mitm.c_token, 4);
            w+=4;

            write_packet(output, w-output, forw);
            break;
        }

        ////////////////////////////////////////////////////////////////////////
        // Play

        case SP_SpawnPlayer: {
            Rvarint(eid);
            Rstr(uuid);
            Rstr(name);
            Rint(x);
            Rint(y);
            Rint(z);
            Rchar(yaw);
            Rchar(pitch);
            Rshort(item);
            //TODO: metadata

            // track players
            import_packet(ptr, len);
            hexdump(ptr, len);

            char msg[32768];
            sprintf(msg, "Player %s at %d,%d,%d",name,x>>5,y>>5,z>>5);
            chat_message(msg, forw, "blue");
            write_packet(ptr, len, forw);
            break;
        }

        case SP_SoundEffect: {
            Rstr(name);
            Rint(x);
            Rint(y);
            Rint(z);
            Rfloat(volume);
            Rchar(pitch);
            if (!strcmp(name,"ambient.weather.thunder")) {
                printf("**** THUNDER ****\n"
                       "coords=%d,%d,%d vol=%.4f pitch=%d\n",
                       x,y,z,volume,pitch);
                close(mitm.ms);
            }
            write_packet(ptr, len, forw);
            break;
        }

        case SP_Effect: {
            Rint(efid);
            Rint(x);
            Rchar(y);
            Rint(z);
            Rint(data);
            Rchar(disrv);
            if (efid == 1013) {
                printf("**** Wither Spawn ****  efid=%d data=%d bcoord=%d:%d:%d %s\n",
                       efid,data,x,y,z,disrv?"disable relative volume":"");
            }
            break;
        }

        case SP_PlayerPositionLook:
        case SP_SpawnObject:
        case SP_SpawnMob:
        case SP_SpawnPainting:
        case SP_SpawnExperienceOrb:
        case SP_DestroyEntities:
        //case SP_Entity:
        case SP_EntityRelMove:
        //case SP_EntityLook:
        case SP_EntityLookRelMove:
        case SP_EntityTeleport:
        {
            import_packet(ptr, len);
            write_packet(ptr, len, forw);
            break;
        }


        case CP_ChatMessage: {
            Rstr(msg);
            if (msg[0] == '#') {
                if (process_message(msg, forw, retour))
                    break;
            }

            // if it was a normal chat message, just forward it
            write_packet(ptr, len, forw);
            break;
        }

        ////////////////////////////////////////////////////////////////////////
        default: {
            // by default, just forward the packet as is
            write_packet(ptr, len, forw);
        }
    }

}

ssize_t handle_proxy(lh_conn *conn) {
    int is_client = (conn->priv != NULL);

    if (conn->status&CONN_STATUS_REMOTE_EOF) {
        // one of the parties has closed the connection.
        // close both sides, deinit the MITM state and
        // remove our descriptors from the pollarray

        close(mitm.cs);
        close(mitm.ms);
        mitm.state = STATE_IDLE;
        mitm.cs = mitm.ms = -1;
        lh_conn_remove(mitm.cs_conn);
        lh_conn_remove(mitm.ms_conn);

        return 0;
    }

    // determine decoded buffers for input (rx), output (tx) and retour (bx)
    lh_buf_t *rx = is_client ? &mitm.cs_rx : &mitm.ms_rx;
    lh_buf_t *tx = is_client ? &mitm.cs_tx : &mitm.ms_tx;
    lh_buf_t *bx = is_client ? &mitm.ms_tx : &mitm.cs_tx;

    assert(conn->rbuf.P(data));

    // sptr,slen - pointer and length of data in the receive buffer
    ssize_t slen = conn->rbuf.C(data) - conn->rbuf.ridx;
    uint8_t *sptr = conn->rbuf.P(data) + conn->rbuf.ridx;

    // provide necessary space in the decoded receive buffer
    ssize_t widx = rx->C(data);
    lh_arr_add(GAR4(rx->data),slen);

#if 0
    printf("*** network data %s ***\n",is_client?"C->S":"C<-S");
    hexdump(sptr, slen);
    printf("************************\n");
#endif

    if (mitm.state == STATE_PLAY) {
        // decryption needed
        int num = 0;
        if (is_client)
            AES_cfb8_encrypt(sptr, rx->P(data)+widx, slen,
                             &mitm.c_aes, mitm.c_dec_iv, &num, AES_DECRYPT);
        else
            AES_cfb8_encrypt(sptr, rx->P(data)+widx, slen,
                             &mitm.s_aes, mitm.s_dec_iv, &num, AES_DECRYPT);
    }
    else {
        // plaintext communication
        memmove(rx->P(data)+widx, sptr, slen);
    }

#if 0
    printf("*** decrypted data %s ***\n",is_client?"C->S":"C<-S");
    hexdump(rx->P(data), rx->C(data));
    printf("************************\n");
#endif

    assert(bx->C(data)==0);

    // try to extract as many packets from the stream as we can in a loop
    while(rx->C(data) > 0) {
        //hexdump(AR(rx->data));
        // do we have a complete packet?
        uint8_t *p = rx->P(data);

        // large varint, data is definitely too short
        if (((*p)&0x80)&&(rx->C(data)<129)) break;

        uint32_t plen = lh_read_varint(p);
        ssize_t ll = p-rx->P(data); // length of the varint
        if (plen+ll > rx->C(data)) break; // packet is incomplete

        process_packet(is_client, p, plen, tx, bx);
        lh_arr_delete_range(GAR4(rx->data),0,ll+plen);
    }

    if (tx->C(data) > 0) {
        if (mitm.state == STATE_PLAY) {
            // since we always write out all data, we just encrypt this in-place
            int num=0;
            if (is_client)
                AES_cfb8_encrypt(tx->P(data), tx->P(data), tx->C(data),
                                 &mitm.s_aes, mitm.s_enc_iv, &num, AES_ENCRYPT);
            else
                AES_cfb8_encrypt(tx->P(data), tx->P(data), tx->C(data),
                                 &mitm.c_aes, mitm.c_enc_iv, &num, AES_ENCRYPT);
        }
        
        lh_conn_write(is_client?mitm.ms_conn:mitm.cs_conn, AR(tx->data));
        tx->C(data) = tx->ridx = 0;
    }
    
    if (bx->C(data) > 0) {
        if (mitm.state == STATE_PLAY) {
            // since we always write out all data, we just encrypt this in-place
            int num=0;
            if (is_client)
                AES_cfb8_encrypt(bx->P(data), bx->P(data), bx->C(data),
                                 &mitm.c_aes, mitm.c_enc_iv, &num, AES_ENCRYPT);
            else
                AES_cfb8_encrypt(bx->P(data), bx->P(data), bx->C(data),
                                 &mitm.s_aes, mitm.s_enc_iv, &num, AES_ENCRYPT);
        }
        hexdump(AR(bx->data));
        lh_conn_write(is_client?mitm.cs_conn:mitm.ms_conn, AR(bx->data));
        bx->C(data) = bx->ridx = 0;
    }
    
    if (mitm.enable_encryption) {
        // init the encryption
        // this is delayed so the last packet (CL_EncryptionResponse) can go out unencrypted
        AES_set_encrypt_key(mitm.c_skey, 128, &mitm.c_aes);
        memcpy(mitm.c_enc_iv, mitm.c_skey, 16);
        memcpy(mitm.c_dec_iv, mitm.c_skey, 16);

        AES_set_encrypt_key(mitm.s_skey, 128, &mitm.s_aes);
        memcpy(mitm.s_enc_iv, mitm.s_skey, 16);
        memcpy(mitm.s_dec_iv, mitm.s_skey, 16);

        printf("c_skey:   "); hexdump(mitm.c_skey,16);
        printf("c_enc_iv: "); hexdump(mitm.c_enc_iv,16);
        printf("c_dec_iv: "); hexdump(mitm.c_dec_iv,16);
        printf("s_skey:   "); hexdump(mitm.s_skey,16);
        printf("s_enc_iv: "); hexdump(mitm.s_enc_iv,16);
        printf("s_dec_iv: "); hexdump(mitm.s_dec_iv,16);

        mitm.state = STATE_PLAY;
        mitm.enable_encryption=0;
    }

    return slen;
}

////////////////////////////////////////////////////////////////////////////////

#if 0
//POST /session/minecraft/join HTTP/1.1
//Content-Type: application/json; charset=utf-8
//Cache-Control: no-cache
//Pragma: no-cache
//User-Agent: Java/1.6.0_27
//Host: ssessionserver.mojang.com
//Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
//Connection: keep-alive
//Content-Length: 156

//{"accessToken":"bbc3cae3264e4ad0b446fd9bb852519a","selectedProfile":"962c6718688448d4a35c249f8d30428b","serverId":"bd651042ec97910e449e11a3991e1274e3e67e5"}HTTP/1.1 401 Authorization Required

//HTTP/1.1 204 No Content                                                                                                    
//Accept-Ranges: bytes                                                                                                       
//Content-length: 0                                                                                                                     
//Date: Mon, 21 Apr 2014 13:13:54 GMT                                                                                                   
//Server: Restlet-Framework/2.2.0                                                                                                       
//Connection: keep-alive                                                                                                                
                                                                                                                                             
#endif

int parseJson(const char *buf, const char *str, char *dst, ssize_t size) {
    const char *name = strstr(buf, str);
    if (!name) return 0;

    while(*name != ':') name++;
    while(*name != '"') name++;
    name++; // now it points to the start of the value

    char *d = dst;
    while(*name != '"' && ((d-dst)<(size-1))) { *d++ = *name++; }
    *d = 0;

    return 1;
}

int handle_session_server(int sfd) {
    // accept connection from the client side
    struct sockaddr_in cadr;
    int cs = lh_accept_tcp4(sfd, &cadr);
    lh_net_blocking(cs);
    if (cs < 0)
        LH_ERROR(0, "Failed to accept the client-side connection");
    printf("Accepted from %s:%d (Webserver)\n",
           inet_ntoa(cadr.sin_addr),ntohs(cadr.sin_port));

    // create a stream connection
    FILE *fp = fdopen(cs,"r+");
    if (!fp) {
        close(cs);
        LH_ERROR(0, "Failed to create a stream connection");
    }

    // read the header
    int clen = 0;
    char buf[262144];
    while(1) {
        if (!fgets(buf, sizeof(buf), fp)) {
            fclose(fp);
            LH_ERROR(0, "Failed to read the header");
        }

        printf(">%s<\n",buf);

        if (!memcmp(buf, "\r\n\0", 3))
            break;

        if (sscanf(buf, "Content-Length: %u", &clen)==1)
            printf("parsed the content length : %d\n",clen);
    }
    printf("parsed the header completely\n");

    // read the POST body
    fread(buf, 1, clen, fp);

    hexdump(buf, clen);
    buf[clen] = 0;
    printf(">%s<\n",buf);

    // parse the JSON (Q&D)
    if ( ! (
            parseJson(buf,"accessToken",mitm.accessToken,sizeof(mitm.accessToken))&&
            parseJson(buf,"selectedProfile",mitm.selectedProfile,sizeof(mitm.selectedProfile))&&
            parseJson(buf,"serverId",mitm.serverId,sizeof(mitm.serverId))
            )) {
        fclose(fp);
        LH_ERROR(0, "Failed to parse JSON");
    }

    printf("accessToken:     >%s<\n",mitm.accessToken);
    printf("selectedProfile: >%s<\n",mitm.selectedProfile);
    printf("serverId:        >%s<\n",mitm.serverId);


    // send response
    time_t ts;
    time(&ts);
    fprintf(fp,
            "HTTP/1.1 204 No Content\r\n"
            "Accept-Ranges: bytes\r\n"
            "Content-length: 0\r\n"
            "Date: %s\r\n"
            "Server: Restlet-Framework/2.2.0\r\n"
            "Connection: keep-alive\r\n"
            "\r\n",asctime(gmtime(&ts)));
    fflush(fp);
    fclose(fp);
    return 1;
}

void print_hex(char *buf, const char *data, ssize_t len) {
    int i;
    char *w = buf;
    int f = 0;
    if (data[0] < 0) {
        *w++ = '-';
        f = 1;
    }
    for(i=0; i<len; i++) {
        char d = data[i];
        if (f) {
            d = -d;
            if (i<len-1)
                d--;
        }
        
        sprintf(w,"%02x",(unsigned char)d);
        w+=2;
    }

    *w++ = 0;

    w = buf+f;
    char *z = w;
    while(*z == '0') z++;
    while(*z) *w++ = *z++;
    *w++ = 0;
}

#include <curl/curl.h>

int query_auth_server() {
    // the final touch - send the authentication token to the session server
    unsigned char md[SHA_DIGEST_LENGTH];
    SHA_CTX sha; CLEAR(sha);
    
    SHA1_Init(&sha);
    SHA1_Update(&sha, mitm.s_id, strlen(mitm.s_id));
    SHA1_Update(&sha, mitm.s_skey, sizeof(mitm.s_skey));
    SHA1_Update(&sha, mitm.s_pkey, mitm.s_pklen);
    SHA1_Final(md, &sha);
    
    char auth[4096];
    hexdump(md, SHA_DIGEST_LENGTH);
    print_hex(auth, md, SHA_DIGEST_LENGTH);
    printf("sessionId : %s\n", auth);

    char buf[4096];
    sprintf(buf,"{\"accessToken\":\"%s\",\"selectedProfile\":\"%s\",\"serverId\":\"%s\"}",
            mitm.accessToken, mitm.selectedProfile, auth);

    // perform a request with a cURL client

    CURL *curl = curl_easy_init();
    CURLcode res;

    // set header options
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_easy_setopt(curl, CURLOPT_URL, "https://sessionserver.mojang.com/session/minecraft/join");
    curl_easy_setopt(curl, CURLOPT_USERAGENT, "Java/1.6.0_27");
    
    struct curl_slist *headerlist=NULL;
    headerlist = curl_slist_append(headerlist, "Content-Type: application/json; charset=utf-8");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);

    // set body - our JSON blob
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, buf);

    // make a request
    res = curl_easy_perform(curl);
    if(res != CURLE_OK)
        fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
 
    curl_easy_cleanup(curl);
    curl_global_cleanup();

    return 1;
}

////////////////////////////////////////////////////////////////////////////////

#define MAX_ENTITIES 4096
#define MAX_ATTACK   1

int is_hostile_entity(entity *e) {
    return e->hostile > 0;
}

int handle_async() {
    if (mitm.opt.autokill) {
        //TODO: limit message rate

        // calculate list of hostile entities in range
        int hent[MAX_ENTITIES];

        //TODO: sort entities by how dangerous and how close they are
        int nhent = get_entities_in_range(hent,MAX_ENTITIES,6.0,is_hostile_entity,NULL);

        //TODO: select primary weapon for priority targets

        //TODO: turn to target

        int i;
        for(i=0; i<MAX_ATTACK && i<nhent; i++) {
            entity *e = gs.P(entity)+hent[i];
            uint8_t pkt[4096], *p;

            // wave arm
            p = pkt;
            write_varint(p,0x0a); // Animation
            write_char(p,0x01);
            write_packet(pkt, p-pkt, &mitm.cs_tx);

            // attack entity
            p = pkt;
            write_varint(p,0x02); // Use Entity
            write_int(p, e->id);
            write_char(p, 0x01);
            write_packet(pkt, p-pkt, &mitm.cs_tx);
        }
    }


    return 0;
}

////////////////////////////////////////////////////////////////////////////////

int handle_server(int sfd, uint32_t ip, uint16_t port) {
    LH_HERE;
    // accept connection from the local client
    struct sockaddr_in cadr;
    int cs = lh_accept_tcp4(sfd, &cadr);
    if (cs < 0)
        LH_ERROR(0, "Failed to accept the client-side connection");

    printf("Accepted from %s:%d\n",
           inet_ntoa(cadr.sin_addr),ntohs(cadr.sin_port));
    
    // open connection to the remote server
    int ms = lh_connect_tcp4(ip, port);
    if (ms < 0) {
        close(mitm.cs);
        LH_ERROR(0, "Failed to open the client-side connection");
    }

    // TCP connections established, 
    printf("New connection: cs=%d ms=%d\n", cs, ms);
    
    // initialize mitm struct, terminate old state if any
    if (mitm.output) fclose(mitm.output);
    if (mitm.output) fclose(mitm.dbg);
    if (mitm.s_rsa) RSA_free(mitm.s_rsa);
    if (mitm.c_rsa) RSA_free(mitm.c_rsa);
    CLEAR(mitm);

    reset_gamestate();
    set_option(GSOP_PRUNE_CHUNKS, 1);
    set_option(GSOP_SEARCH_SPAWNERS, 1);
    set_option(GSOP_TRACK_ENTITIES, 1);

    char fname[4096];
    time_t t;
    time(&t);
    strftime(fname, sizeof(fname), "saved/%Y%m%d_%H%M%S.mcs",localtime(&t));
    mitm.output = fopen(fname, "w");
    setvbuf(mitm.output, NULL, _IONBF, 0);
    strftime(fname, sizeof(fname), "saved/%Y%m%d_%H%M%S.dbg",localtime(&t));
    mitm.dbg = fopen(fname, "w");
    setvbuf(mitm.dbg, NULL, _IONBF, 0);

    // handle_server was able to accept the client connection and
    // also open the server-side connection, we need to add these
    // new sockets to the groups cg and mg respectively
    mitm.cs = cs;
    mitm.ms = ms;
    mitm.cs_conn = lh_conn_add(&pa, cs, G_PROXY, (void*)1);
    mitm.ms_conn = lh_conn_add(&pa, ms, G_PROXY, (void*)0);

    return 1;
}

////////////////////////////////////////////////////////////////////////////////

int proxy_pump(uint32_t ip, uint16_t port) {
    CLEAR(pa);

    CLEAR(mitm);
    mitm.cs = mitm.ms = -1;

    // Minecraft proxy server
    int ss = lh_listen_tcp4_any(port);
    if (ss<0) return -1;
    lh_poll_add(&pa, ss, POLLIN, G_MCSERVER, NULL);

    // fake session.minecraft.com web server
    int ws = lh_listen_tcp4_any(WEBSERVER_PORT);
    if (ws<0) return -1;
    lh_poll_add(&pa, ws, POLLIN, G_WEBSERVER, NULL);

    // prepare signal handling
    signal_caught = 0;
    struct sigaction sa;
    CLEAR(sa);
    sa.sa_handler = signal_handler;
    if (sigaction(SIGINT, &sa, NULL))
        LH_ERROR(1,"Failed to set sigaction\n");

    // main pump
    int i;
    while(!signal_caught) {
        lh_poll(&pa, 1000);

        lh_polldata *pd;
        int pos;

        // handle connection requests on the web server
        if ( pd=lh_poll_getfirst(&pa, G_WEBSERVER, POLLIN))
            handle_session_server(pd->fd);

        if ( pd=lh_poll_getfirst(&pa, G_MCSERVER, POLLIN))
            handle_server(pd->fd, ip, port);

        // handle client- and server-side connection
        lh_conn_process(&pa, G_PROXY, handle_proxy);

        // handle asynchronous events
        handle_async();
    }

    printf("Terminating...\n");
    if (mitm.output) {
        fflush(mitm.output);
        fclose(mitm.output);
        mitm.output = NULL;
    }
    if (mitm.dbg) {
        fclose(mitm.dbg);
        mitm.dbg = NULL;
    }
}

int main(int ac, char **av) {
    uint32_t server_ip = lh_dns_addr_ipv4(av[1]?av[1]:SERVER_ADDR);
    if (server_ip == 0xffffffff)
        LH_ERROR(-1, "Failed to obtain IP address for the server %s",SERVER_ADDR);
        
    proxy_pump(server_ip, SERVER_PORT);

    return 0;
}
