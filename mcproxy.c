#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <sys/socket.h>
#include <signal.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <time.h>
#include <math.h>

#include <openssl/rsa.h>
#include <openssl/x509.h>
#include <openssl/sha.h>
#include <openssl/aes.h>

#include <curl/curl.h>

#define LH_DECLARE_SHORT_NAMES 1

#include "lh_debug.h"
#include "lh_buffers.h"
#include "lh_bytes.h"
#include "lh_files.h"
#include "lh_net.h"
#include "lh_event.h"
#include "lh_compress.h"
#include "lh_arr.h"

#include "mcp_ids.h"
#include "mcp_gamestate.h"
#include "mcp_game.h"

#define SERVER_ADDR "2b2t.org"

#define SERVER_PORT 25565
#define WEBSERVER_PORT 8080

#define ASYNC_THRESHOLD 500000
#define NEAR_THRESHOLD 40000

#define G_MCSERVER  1
#define G_WEBSERVER 2
#define G_PROXY     3

////////////////////////////////////////////////////////////////////////////////

int signal_caught;

void signal_handler(int signum) {
    printf("Caught signal %d, stopping main loop\n",signum);
    signal_caught = 1;
}

////////////////////////////////////////////////////////////////////////////////

lh_pollarray pa;

struct {
    int state;          // handshake state

    int cs;             // connected socket to client
    int ms;             // connected socket to server

    // connections
    lh_conn * cs_conn; // to the client
    lh_conn * ms_conn; // to the server

    // decoded buffers
    lh_buf_t  cs_rx;   // client -> proxy
    lh_buf_t  cs_tx;   // proxy -> client
    lh_buf_t  ms_rx;   // server -> proxy
    lh_buf_t  ms_tx;   // proxy -> server

    // RSA structures/keys for server-side and client-side
    RSA *s_rsa; // public key only - must be freed by RSA_free
    RSA *c_rsa; // public+private key - must be freed by RSA_free

    // verification tokens
    char s_token[4]; // what we received from the server
    char c_token[4]; // generated by us, sent to client

    // AES encryption keys (128 bit)
    char s_skey[16]; // generated by us, sent to the server
    char c_skey[16]; // received from the client

    // data parsed from JSON
    char accessToken[256];
    char selectedProfile[256];
    char serverId[256];

    // server ID - we forward this to client as is, so no need
    // for client- and server side versions.
    // zero-terminated string, so no need for length value
    // Note: serverID is received as UTF-16 string, but converted to ASCII
    // for hashing. The string itself is a hexstring, but it's not converted
    // to bytes or anything
    char s_id[256];

    // DER-encoded public key from the server
    char s_pkey[1024];
    int s_pklen;

    // DER-encoded public key sent to the client
    char c_pkey[1024];
    int c_pklen;

    int encstate;
    int passfirst;

    AES_KEY c_aes;
    char c_enc_iv[16];
    char c_dec_iv[16];

    AES_KEY s_aes;
    char s_enc_iv[16];
    char s_dec_iv[16];

    int enable_encryption;

    FILE * output;
    FILE * dbg;
} mitm;

////////////////////////////////////////////////////////////////////////////////

void process_encryption_request(uint8_t *p, lh_buf_t *forw) {
    Rstr(serverID);

    Rshort(klen);
    memmove(mitm.s_pkey,p,klen);
    Rskip(klen);

    Rshort(tlen);
    memmove(mitm.s_token,p,tlen);
    Rskip(tlen);

    printf("Encryption Request\n");
                
    sprintf(mitm.s_id,"%s",serverID);
    mitm.s_pklen = klen;
                
    // decode server PUBKEY to an RSA struct
    unsigned char *pp = mitm.s_pkey;
    d2i_RSA_PUBKEY(&mitm.s_rsa, (const unsigned char **)&pp, klen);
    if (mitm.s_rsa == NULL) {
        printf("Failed to decode the server's public key\n");
        exit(1);
    }
    RSA_print_fp(stdout, mitm.s_rsa, 4);

    // generate the server-side shared key pair
    RAND_pseudo_bytes(mitm.s_skey, 16);
    printf("Server-side shared key: ");
    hexprint(mitm.s_skey, 16);

    // create a client-side RSA
    mitm.c_rsa = RSA_generate_key(1024, RSA_F4, NULL, NULL);
    if (mitm.c_rsa == NULL) {
        printf("Failed to generate client-side RSA key\n");
        exit(1);
    }
    RSA_print_fp(stdout, mitm.c_rsa, 4);
    
    // encode the client-side pubkey as DER
    pp = mitm.c_pkey;
    mitm.c_pklen = i2d_RSA_PUBKEY(mitm.c_rsa, &pp);

    // generate the client-side verification token
    RAND_pseudo_bytes(mitm.c_token, 4);

    // combine it to a MCP message to the client
    uint8_t output[65536];
    uint8_t *w = output;

    write_varint(w, PID(SL_EncryptionRequest));
    write_varint(w, strlen(serverID));
    memmove(w, serverID, strlen(serverID));
    w+=strlen(serverID);
    write_short(w, mitm.c_pklen);
    memmove(w, mitm.c_pkey, mitm.c_pklen);
    w+=mitm.c_pklen;
    write_short(w, 4);
    memmove(w, mitm.c_token, 4);
    w+=4;
    
    write_packet(output, w-output, forw);
}

void process_encryption_response(uint8_t *p, lh_buf_t *forw) {
    Rshort(sklen);
    uint8_t *skey = p;
    Rskip(sklen);
    Rshort(tklen);
    uint8_t *token = p;
    Rskip(tklen);

    char buf[4096];
    int dklen = RSA_private_decrypt(sklen, skey, buf, mitm.c_rsa, RSA_PKCS1_PADDING);
    if (dklen < 0) {
        printf("Failed to decrypt the shared key received from the client\n");
        exit(1);
    }
    printf("Decrypted client shared key, keylen=%d ",dklen);
    hexprint(buf, dklen);
    memcpy(mitm.c_skey, buf, 16);
    
    int dtlen = RSA_private_decrypt(tklen, token, buf, mitm.c_rsa, RSA_PKCS1_PADDING);
    if (dtlen < 0) {
        printf("Failed to decrypt the verification token received from the client\n");
        exit(1);
    }
    printf("Decrypted client token, len=%d ",dtlen);
    hexprint(buf, dtlen);
    printf("Original token: ");
    hexprint(mitm.c_token,4);
    if (memcmp(buf, mitm.c_token, 4)) {
        printf("Token does not match!\n");
        exit(1);
    }
            
    uint8_t output[65536];
    uint8_t *w = output;

    // at this point, the client side is verified and the key is established
    // now send our response to the server
    write_varint(w, PID(CL_EncryptionResponse));

    int eklen = RSA_public_encrypt(sizeof(mitm.s_skey), mitm.s_skey, buf, mitm.s_rsa, RSA_PKCS1_PADDING);
    write_short(w,(short)eklen);
    memcpy(w, buf, eklen);
    w += eklen;
            
    int etlen = RSA_public_encrypt(sizeof(mitm.s_token), mitm.s_token, buf, mitm.s_rsa, RSA_PKCS1_PADDING);
    write_short(w,(short)etlen);
    memcpy(w, buf, etlen);
    w += etlen;
                
    query_auth_server();
    hexdump(output, w-output);
    write_packet(output, w-output, forw);

    mitm.enable_encryption = 1;
}

ssize_t handle_proxy(lh_conn *conn) {
    int is_client = (conn->priv != NULL);

    if (conn->status&CONN_STATUS_REMOTE_EOF) {
        // one of the parties has closed the connection.
        // close both sides, deinit the MITM state and
        // remove our descriptors from the pollarray

        close(mitm.cs);
        close(mitm.ms);
        mitm.state = STATE_IDLE;
        mitm.cs = mitm.ms = -1;
        lh_conn_remove(mitm.cs_conn);
        lh_conn_remove(mitm.ms_conn);

        return 0;
    }

    // determine decoded buffers for input (rx), output (tx) and retour (bx)
    lh_buf_t *rx = is_client ? &mitm.cs_rx : &mitm.ms_rx;
    lh_buf_t *tx = is_client ? &mitm.cs_tx : &mitm.ms_tx;
    lh_buf_t *bx = is_client ? &mitm.ms_tx : &mitm.cs_tx;

    assert(conn->rbuf.P(data));

    // sptr,slen - pointer and length of data in the receive buffer
    ssize_t slen = conn->rbuf.C(data) - conn->rbuf.ridx;
    uint8_t *sptr = conn->rbuf.P(data) + conn->rbuf.ridx;

    // provide necessary space in the decoded receive buffer
    ssize_t widx = rx->C(data);
    lh_arr_add(GAR4(rx->data),slen);

#if 0
    printf("*** network data %s ***\n",is_client?"C->S":"C<-S");
    hexdump(sptr, slen);
    printf("************************\n");
#endif

    if (mitm.state == STATE_PLAY) {
        // decryption needed
        int num = 0;
        if (is_client)
            AES_cfb8_encrypt(sptr, rx->P(data)+widx, slen,
                             &mitm.c_aes, mitm.c_dec_iv, &num, AES_DECRYPT);
        else
            AES_cfb8_encrypt(sptr, rx->P(data)+widx, slen,
                             &mitm.s_aes, mitm.s_dec_iv, &num, AES_DECRYPT);
    }
    else {
        // plaintext communication
        memmove(rx->P(data)+widx, sptr, slen);
    }

#if 0
    printf("*** decrypted data %s ***\n",is_client?"C->S":"C<-S");
    hexdump(rx->P(data), rx->C(data));
    printf("************************\n");
#endif

    //assert(bx->C(data)==0);

    // try to extract as many packets from the stream as we can in a loop
    while(rx->C(data) > 0) {
        //hexdump(AR(rx->data));
        // do we have a complete packet?
        uint8_t *p = rx->P(data);

        // large varint, data is definitely too short
        if (((*p)&0x80)&&(rx->C(data)<129)) break;

        uint32_t plen = lh_read_varint(p);
        ssize_t ll = p-rx->P(data); // length of the varint
        if (plen+ll > rx->C(data)) break; // packet is incomplete

        if (mitm.output) {
            // write packet to the MCS file
            struct timeval tv;
            gettimeofday(&tv, NULL);

            uint8_t header[4096];
            uint8_t *hp = header;
            write_int(hp, is_client);
            write_int(hp, tv.tv_sec);
            write_int(hp, tv.tv_usec);
            write_int(hp, plen);
            fwrite(header, 1, hp-header, mitm.output);
            fwrite(p, 1, plen, mitm.output);
            fflush(mitm.output);
        }        

        process_packet(is_client, p, plen, tx, bx, &mitm.state);
        lh_arr_delete_range(GAR4(rx->data),0,ll+plen);
    }

    if (tx->C(data) > 0) {
        if (mitm.state == STATE_PLAY) {
            // since we always write out all data, we just encrypt this in-place
            int num=0;
            if (is_client)
                AES_cfb8_encrypt(tx->P(data), tx->P(data), tx->C(data),
                                 &mitm.s_aes, mitm.s_enc_iv, &num, AES_ENCRYPT);
            else
                AES_cfb8_encrypt(tx->P(data), tx->P(data), tx->C(data),
                                 &mitm.c_aes, mitm.c_enc_iv, &num, AES_ENCRYPT);
        }
        
        lh_conn_write(is_client?mitm.ms_conn:mitm.cs_conn, AR(tx->data));
        tx->C(data) = tx->ridx = 0;
    }
    
    if (bx->C(data) > 0) {
        if (mitm.state == STATE_PLAY) {
            // since we always write out all data, we just encrypt this in-place
            int num=0;
            if (is_client)
                AES_cfb8_encrypt(bx->P(data), bx->P(data), bx->C(data),
                                 &mitm.c_aes, mitm.c_enc_iv, &num, AES_ENCRYPT);
            else
                AES_cfb8_encrypt(bx->P(data), bx->P(data), bx->C(data),
                                 &mitm.s_aes, mitm.s_enc_iv, &num, AES_ENCRYPT);
        }
        lh_conn_write(is_client?mitm.cs_conn:mitm.ms_conn, AR(bx->data));
        bx->C(data) = bx->ridx = 0;
    }
    
    if (mitm.enable_encryption) {
        // init the encryption
        // this is delayed so the last packet (CL_EncryptionResponse) can go out unencrypted
        AES_set_encrypt_key(mitm.c_skey, 128, &mitm.c_aes);
        memcpy(mitm.c_enc_iv, mitm.c_skey, 16);
        memcpy(mitm.c_dec_iv, mitm.c_skey, 16);

        AES_set_encrypt_key(mitm.s_skey, 128, &mitm.s_aes);
        memcpy(mitm.s_enc_iv, mitm.s_skey, 16);
        memcpy(mitm.s_dec_iv, mitm.s_skey, 16);

        printf("c_skey:   "); hexdump(mitm.c_skey,16);
        printf("c_enc_iv: "); hexdump(mitm.c_enc_iv,16);
        printf("c_dec_iv: "); hexdump(mitm.c_dec_iv,16);
        printf("s_skey:   "); hexdump(mitm.s_skey,16);
        printf("s_enc_iv: "); hexdump(mitm.s_enc_iv,16);
        printf("s_dec_iv: "); hexdump(mitm.s_dec_iv,16);

        mitm.state = STATE_PLAY;
        mitm.enable_encryption=0;
    }

    return slen;
}

void drop_connection() {
    close(mitm.ms);
    close(mitm.cs);
}

////////////////////////////////////////////////////////////////////////////////
// Session Server

#if 0
//POST /session/minecraft/join HTTP/1.1
//Content-Type: application/json; charset=utf-8
//Cache-Control: no-cache
//Pragma: no-cache
//User-Agent: Java/1.6.0_27
//Host: ssessionserver.mojang.com
//Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
//Connection: keep-alive
//Content-Length: 156

//{"accessToken":"bbc3cae3264e4ad0b446fd9bb852519a","selectedProfile":"962c6718688448d4a35c249f8d30428b","serverId":"bd651042ec97910e449e11a3991e1274e3e67e5"}HTTP/1.1 401 Authorization Required

//HTTP/1.1 204 No Content                                                                                                    
//Accept-Ranges: bytes                                                                                                       
//Content-length: 0                                                                                                                     
//Date: Mon, 21 Apr 2014 13:13:54 GMT                                                                                                   
//Server: Restlet-Framework/2.2.0                                                                                                       
//Connection: keep-alive                                                                                                                
                                                                                                                                             
#endif

int parseJson(const char *buf, const char *str, char *dst, ssize_t size) {
    const char *name = strstr(buf, str);
    if (!name) return 0;

    while(*name != ':') name++;
    while(*name != '"') name++;
    name++; // now it points to the start of the value

    char *d = dst;
    while(*name != '"' && ((d-dst)<(size-1))) { *d++ = *name++; }
    *d = 0;

    return 1;
}

int handle_session_server(int sfd) {
    // accept connection from the client side
    struct sockaddr_in cadr;
    int cs = lh_accept_tcp4(sfd, &cadr);
    lh_net_blocking(cs);
    if (cs < 0)
        LH_ERROR(0, "Failed to accept the client-side connection");
    printf("Accepted from %s:%d (Webserver)\n",
           inet_ntoa(cadr.sin_addr),ntohs(cadr.sin_port));

    // create a stream connection
    FILE *fp = fdopen(cs,"r+");
    if (!fp) {
        close(cs);
        LH_ERROR(0, "Failed to create a stream connection");
    }

    // read the header
    int clen = 0;
    char buf[262144];
    while(1) {
        if (!fgets(buf, sizeof(buf), fp)) {
            fclose(fp);
            LH_ERROR(0, "Failed to read the header");
        }

        printf(">%s<\n",buf);

        if (!memcmp(buf, "\r\n\0", 3))
            break;

        if (sscanf(buf, "Content-Length: %u", &clen)==1)
            printf("parsed the content length : %d\n",clen);
    }
    printf("parsed the header completely\n");

    // read the POST body
    fread(buf, 1, clen, fp);

    hexdump(buf, clen);
    buf[clen] = 0;
    printf(">%s<\n",buf);

    // parse the JSON (Q&D)
    if ( ! (
            parseJson(buf,"accessToken",mitm.accessToken,sizeof(mitm.accessToken))&&
            parseJson(buf,"selectedProfile",mitm.selectedProfile,sizeof(mitm.selectedProfile))&&
            parseJson(buf,"serverId",mitm.serverId,sizeof(mitm.serverId))
            )) {
        fclose(fp);
        LH_ERROR(0, "Failed to parse JSON");
    }

    printf("accessToken:     >%s<\n",mitm.accessToken);
    printf("selectedProfile: >%s<\n",mitm.selectedProfile);
    printf("serverId:        >%s<\n",mitm.serverId);


    // send response
    time_t ts;
    time(&ts);
    fprintf(fp,
            "HTTP/1.1 204 No Content\r\n"
            "Accept-Ranges: bytes\r\n"
            "Content-length: 0\r\n"
            "Date: %s\r\n"
            "Server: Restlet-Framework/2.2.0\r\n"
            "Connection: keep-alive\r\n"
            "\r\n",asctime(gmtime(&ts)));
    fflush(fp);
    fclose(fp);
    return 1;
}

void print_hex(char *buf, const char *data, ssize_t len) {
    int i;
    char *w = buf;
    int f = 0;
    if (data[0] < 0) {
        *w++ = '-';
        f = 1;
    }
    for(i=0; i<len; i++) {
        char d = data[i];
        if (f) {
            d = -d;
            if (i<len-1)
                d--;
        }
        
        sprintf(w,"%02x",(unsigned char)d);
        w+=2;
    }

    *w++ = 0;

    w = buf+f;
    char *z = w;
    while(*z == '0') z++;
    while(*z) *w++ = *z++;
    *w++ = 0;
}

int query_auth_server() {
    // the final touch - send the authentication token to the session server
    unsigned char md[SHA_DIGEST_LENGTH];
    SHA_CTX sha; CLEAR(sha);
    
    SHA1_Init(&sha);
    SHA1_Update(&sha, mitm.s_id, strlen(mitm.s_id));
    SHA1_Update(&sha, mitm.s_skey, sizeof(mitm.s_skey));
    SHA1_Update(&sha, mitm.s_pkey, mitm.s_pklen);
    SHA1_Final(md, &sha);
    
    char auth[4096];
    hexdump(md, SHA_DIGEST_LENGTH);
    print_hex(auth, md, SHA_DIGEST_LENGTH);
    printf("sessionId : %s\n", auth);

    char buf[4096];
    sprintf(buf,"{\"accessToken\":\"%s\",\"selectedProfile\":\"%s\",\"serverId\":\"%s\"}",
            mitm.accessToken, mitm.selectedProfile, auth);

    // perform a request with a cURL client

    CURL *curl = curl_easy_init();
    CURLcode res;

    // set header options
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_easy_setopt(curl, CURLOPT_URL, "https://sessionserver.mojang.com/session/minecraft/join");
    curl_easy_setopt(curl, CURLOPT_USERAGENT, "Java/1.6.0_27");
    
    struct curl_slist *headerlist=NULL;
    headerlist = curl_slist_append(headerlist, "Content-Type: application/json; charset=utf-8");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);

    // set body - our JSON blob
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, buf);

    // make a request
    res = curl_easy_perform(curl);
    if(res != CURLE_OK)
        fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
 
    curl_easy_cleanup(curl);
    curl_global_cleanup();

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
// Minecraft client connections

int handle_server(int sfd, uint32_t ip, uint16_t port) {
    // accept connection from the local client
    struct sockaddr_in cadr;
    int cs = lh_accept_tcp4(sfd, &cadr);
    if (cs < 0)
        LH_ERROR(0, "Failed to accept the client-side connection");

    printf("Accepted from %s:%d\n",
           inet_ntoa(cadr.sin_addr),ntohs(cadr.sin_port));
    
    // open connection to the remote server
    int ms = lh_connect_tcp4(ip, port);
    if (ms < 0) {
        close(mitm.cs);
        LH_ERROR(0, "Failed to open the client-side connection");
    }

    // TCP connections established, 
    printf("New connection: cs=%d ms=%d\n", cs, ms);
    
    // initialize mitm struct, terminate old state if any
    if (mitm.output) fclose(mitm.output);
    if (mitm.dbg)    fclose(mitm.dbg);
    if (mitm.s_rsa) RSA_free(mitm.s_rsa);
    if (mitm.c_rsa) RSA_free(mitm.c_rsa);
    CLEAR(mitm);
    clear_autobuild();

    reset_gamestate();
    set_option(GSOP_PRUNE_CHUNKS, 1);
    set_option(GSOP_SEARCH_SPAWNERS, 1);
    set_option(GSOP_TRACK_ENTITIES, 1);

    char fname[4096];
    time_t t;
    time(&t);
    strftime(fname, sizeof(fname), "saved/%Y%m%d_%H%M%S.mcs",localtime(&t));
    mitm.output = fopen(fname, "w");
    setvbuf(mitm.output, NULL, _IONBF, 0);
    //strftime(fname, sizeof(fname), "saved/%Y%m%d_%H%M%S.dbg",localtime(&t));
    //mitm.dbg = fopen(fname, "w");
    //setvbuf(mitm.dbg, NULL, _IONBF, 0);

    // handle_server was able to accept the client connection and
    // also open the server-side connection, we need to add these
    // new sockets to the groups cg and mg respectively
    mitm.cs = cs;
    mitm.ms = ms;
    mitm.cs_conn = lh_conn_add(&pa, cs, G_PROXY, (void*)1);
    mitm.ms_conn = lh_conn_add(&pa, ms, G_PROXY, (void*)0);

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
// Main loop

int proxy_pump(uint32_t ip, uint16_t port) {
    CLEAR(pa);

    CLEAR(mitm);
    clear_autobuild();
    mitm.cs = mitm.ms = -1;

    // Minecraft proxy server
    int ss = lh_listen_tcp4_any(port);
    if (ss<0) return -1;
    lh_poll_add(&pa, ss, POLLIN, G_MCSERVER, NULL);

    // fake session.minecraft.com web server
    int ws = lh_listen_tcp4_any(WEBSERVER_PORT);
    if (ws<0) return -1;
    lh_poll_add(&pa, ws, POLLIN, G_WEBSERVER, NULL);

    // prepare signal handling
    signal_caught = 0;
    struct sigaction sa;
    CLEAR(sa);
    sa.sa_handler = signal_handler;
    if (sigaction(SIGINT, &sa, NULL))
        LH_ERROR(1,"Failed to set sigaction\n");

    // main pump
    int i;
    while(!signal_caught) {
        lh_poll(&pa, 1000);

        lh_polldata *pd;
        int pos;

        // handle connection requests on the web server
        if ( pd=lh_poll_getfirst(&pa, G_WEBSERVER, POLLIN))
            handle_session_server(pd->fd);

        if ( pd=lh_poll_getfirst(&pa, G_MCSERVER, POLLIN))
            handle_server(pd->fd, ip, port);

        // handle client- and server-side connection
        lh_conn_process(&pa, G_PROXY, handle_proxy);

        // handle asynchronous events
        if (mitm.state == STATE_PLAY)
            handle_async(&mitm.ms_tx, &mitm.cs_tx);
    }

    printf("Terminating...\n");
    if (mitm.output) {
        fflush(mitm.output);
        fclose(mitm.output);
        mitm.output = NULL;
    }
    if (mitm.dbg) {
        fclose(mitm.dbg);
        mitm.dbg = NULL;
    }
}

int main(int ac, char **av) {
    uint32_t server_ip = lh_dns_addr_ipv4(av[1]?av[1]:SERVER_ADDR);
    if (server_ip == 0xffffffff)
        LH_ERROR(-1, "Failed to obtain IP address for the server %s",SERVER_ADDR);
        
    proxy_pump(server_ip, SERVER_PORT);

    return 0;
}
